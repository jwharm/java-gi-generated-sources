package org.gtk.gio;

import io.github.jwharm.javagi.*;
import java.lang.foreign.*;
import java.lang.invoke.*;
import org.jetbrains.annotations.*;

/**
 * Constants and functions that are declared in the global Gio namespace.
 */
public final class Gio {
    
    static {
        System.loadLibrary("gio-2.0");
    }
    
    @ApiStatus.Internal static void javagi$ensureInitialized() {}
    
    /**
     * The value returned by handlers of the signals generated by
     * the {@code gdbus-codegen} tool to indicate that a method call has been
     * handled by an implementation. It is equal to {@code true}, but using
     * this macro is sometimes more readable.
     * <p>
     * In code that needs to be backwards-compatible with older GLib,
     * use {@code true} instead, often written like this:
     * <pre>{@code 
     *   g_dbus_method_invocation_return_error (invocation, ...);
     *   return TRUE;    // handled
     * }</pre>
     */
    public static final boolean DBUS_METHOD_INVOCATION_HANDLED = true;
    
    /**
     * The value returned by handlers of the signals generated by
     * the {@code gdbus-codegen} tool to indicate that a method call has not been
     * handled by an implementation. It is equal to {@code false}, but using
     * this macro is sometimes more readable.
     * <p>
     * In code that needs to be backwards-compatible with older GLib,
     * use {@code false} instead.
     */
    public static final boolean DBUS_METHOD_INVOCATION_UNHANDLED = false;
    
    /**
     * Extension point for debug control functionality.
     * See [Extending GIO][extending-gio].
     */
    public static final java.lang.String DEBUG_CONTROLLER_EXTENSION_POINT_NAME = "gio-debug-controller";
    
    /**
     * Extension point for default handler to URI association. See
     * [Extending GIO][extending-gio].
     */
    public static final java.lang.String DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME = "gio-desktop-app-info-lookup";
    
    /**
     * The string used to obtain a Unix device path with g_drive_get_identifier().
     */
    public static final java.lang.String DRIVE_IDENTIFIER_KIND_UNIX_DEVICE = "unix-device";
    
    /**
     * A key in the "access" namespace for checking deletion privileges.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     * <p>
     * This attribute will be {@code true} if the user is able to delete the file.
     */
    public static final java.lang.String FILE_ATTRIBUTE_ACCESS_CAN_DELETE = "access::can-delete";
    
    /**
     * A key in the "access" namespace for getting execution privileges.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     * <p>
     * This attribute will be {@code true} if the user is able to execute the file.
     */
    public static final java.lang.String FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE = "access::can-execute";
    
    /**
     * A key in the "access" namespace for getting read privileges.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     * <p>
     * This attribute will be {@code true} if the user is able to read the file.
     */
    public static final java.lang.String FILE_ATTRIBUTE_ACCESS_CAN_READ = "access::can-read";
    
    /**
     * A key in the "access" namespace for checking renaming privileges.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     * <p>
     * This attribute will be {@code true} if the user is able to rename the file.
     */
    public static final java.lang.String FILE_ATTRIBUTE_ACCESS_CAN_RENAME = "access::can-rename";
    
    /**
     * A key in the "access" namespace for checking trashing privileges.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     * <p>
     * This attribute will be {@code true} if the user is able to move the file to
     * the trash.
     */
    public static final java.lang.String FILE_ATTRIBUTE_ACCESS_CAN_TRASH = "access::can-trash";
    
    /**
     * A key in the "access" namespace for getting write privileges.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     * <p>
     * This attribute will be {@code true} if the user is able to write to the file.
     */
    public static final java.lang.String FILE_ATTRIBUTE_ACCESS_CAN_WRITE = "access::can-write";
    
    /**
     * A key in the "dos" namespace for checking if the file's archive flag
     * is set.
     * <p>
     * This attribute is {@code true} if the archive flag is set.
     * <p>
     * This attribute is only available for DOS file systems.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_DOS_IS_ARCHIVE = "dos::is-archive";
    
    /**
     * A key in the "dos" namespace for checking if the file is a NTFS mount point
     * (a volume mount or a junction point).
     * <p>
     * This attribute is {@code true} if file is a reparse point of type
     * <a href="https://msdn.microsoft.com/en-us/library/dd541667.aspx">IO_REPARSE_TAG_MOUNT_POINT</a>.
     * <p>
     * This attribute is only available for DOS file systems.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT = "dos::is-mountpoint";
    
    /**
     * A key in the "dos" namespace for checking if the file's backup flag
     * is set.
     * <p>
     * This attribute is {@code true} if the backup flag is set.
     * <p>
     * This attribute is only available for DOS file systems.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_DOS_IS_SYSTEM = "dos::is-system";
    
    /**
     * A key in the "dos" namespace for getting the file NTFS reparse tag.
     * <p>
     * This value is 0 for files that are not reparse points.
     * <p>
     * See the <a href="https://msdn.microsoft.com/en-us/library/dd541667.aspx">Reparse Tags</a>
     * page for possible reparse tag values.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG = "dos::reparse-point-tag";
    
    /**
     * A key in the "etag" namespace for getting the value of the file's
     * entity tag.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_ETAG_VALUE = "etag::value";
    
    /**
     * A key in the "filesystem" namespace for getting the number of bytes
     * of free space left on the file system.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT64}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_FILESYSTEM_FREE = "filesystem::free";
    
    /**
     * A key in the "filesystem" namespace for checking if the file system
     * is read only.
     * <p>
     * Is set to {@code true} if the file system is read only.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_FILESYSTEM_READONLY = "filesystem::readonly";
    
    /**
     * A key in the "filesystem" namespace for checking if the file system
     * is remote.
     * <p>
     * Is set to {@code true} if the file system is remote.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_FILESYSTEM_REMOTE = "filesystem::remote";
    
    /**
     * A key in the "filesystem" namespace for getting the total size (in
     * bytes) of the file system, used in g_file_query_filesystem_info().
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT64}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_FILESYSTEM_SIZE = "filesystem::size";
    
    /**
     * A key in the "filesystem" namespace for getting the file system's type.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_FILESYSTEM_TYPE = "filesystem::type";
    
    /**
     * A key in the "filesystem" namespace for getting the number of bytes
     * used by data on the file system.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT64}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_FILESYSTEM_USED = "filesystem::used";
    
    /**
     * A key in the "filesystem" namespace for hinting a file manager
     * application whether it should preview (e.g. thumbnail) files on the
     * file system.
     * <p>
     * The value for this key contain a {@link FilesystemPreviewType}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW = "filesystem::use-preview";
    
    /**
     * A key in the "gvfs" namespace that gets the name of the current
     * GVFS backend in use.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_GVFS_BACKEND = "gvfs::backend";
    
    /**
     * A key in the "id" namespace for getting a file identifier.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     * <p>
     * An example use would be during listing files, to avoid recursive
     * directory scanning.
     */
    public static final java.lang.String FILE_ATTRIBUTE_ID_FILE = "id::file";
    
    /**
     * A key in the "id" namespace for getting the file system identifier.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     * <p>
     * An example use would be during drag and drop to see if the source
     * and target are on the same filesystem (default to move) or not (default
     * to copy).
     */
    public static final java.lang.String FILE_ATTRIBUTE_ID_FILESYSTEM = "id::filesystem";
    
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) can be ejected.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT = "mountable::can-eject";
    
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) is mountable.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT = "mountable::can-mount";
    
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) can be polled.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL = "mountable::can-poll";
    
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) can be started.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_MOUNTABLE_CAN_START = "mountable::can-start";
    
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) can be started degraded.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED = "mountable::can-start-degraded";
    
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) can be stopped.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP = "mountable::can-stop";
    
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE)  is unmountable.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT = "mountable::can-unmount";
    
    /**
     * A key in the "mountable" namespace for getting the HAL UDI for the mountable
     * file.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI = "mountable::hal-udi";
    
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) is automatically polled for media.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC = "mountable::is-media-check-automatic";
    
    /**
     * A key in the "mountable" namespace for getting the {@link DriveStartStopType}.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE = "mountable::start-stop-type";
    
    /**
     * A key in the "mountable" namespace for getting the unix device.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE = "mountable::unix-device";
    
    /**
     * A key in the "mountable" namespace for getting the unix device file.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE = "mountable::unix-device-file";
    
    /**
     * A key in the "owner" namespace for getting the file owner's group.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_OWNER_GROUP = "owner::group";
    
    /**
     * A key in the "owner" namespace for getting the user name of the
     * file's owner.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_OWNER_USER = "owner::user";
    
    /**
     * A key in the "owner" namespace for getting the real name of the
     * user that owns the file.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_OWNER_USER_REAL = "owner::user-real";
    
    /**
     * A key in the "preview" namespace for getting a {@link Icon} that can be
     * used to get preview of the file.
     * <p>
     * For example, it may be a low resolution thumbnail without metadata.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#OBJECT}.
     * <p>
     * The value for this key should contain a {@link Icon}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_PREVIEW_ICON = "preview::icon";
    
    /**
     * A key in the "recent" namespace for getting time, when the metadata for the
     * file in {@code recent:///} was last changed.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#INT64}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_RECENT_MODIFIED = "recent::modified";
    
    /**
     * A key in the "selinux" namespace for getting the file's SELinux
     * context.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     * <p>
     * Note that this attribute is only available if GLib has been built
     * with SELinux support.
     */
    public static final java.lang.String FILE_ATTRIBUTE_SELINUX_CONTEXT = "selinux::context";
    
    /**
     * A key in the "standard" namespace for getting the amount of disk space
     * that is consumed by the file (in bytes).
     * <p>
     * This will generally be larger than the file size (due to block size
     * overhead) but can occasionally be smaller (for example, for sparse files).
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT64}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE = "standard::allocated-size";
    
    /**
     * A key in the "standard" namespace for getting the content type of the file.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     * <p>
     * The value for this key should contain a valid content type.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE = "standard::content-type";
    
    /**
     * A key in the "standard" namespace for getting the copy name of the file.
     * <p>
     * The copy name is an optional version of the name. If available it's always
     * in UTF8, and corresponds directly to the original filename (only transcoded to
     * UTF8). This is useful if you want to copy the file to another filesystem that
     * might have a different encoding. If the filename is not a valid string in the
     * encoding selected for the filesystem it is in then the copy name will not be set.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_COPY_NAME = "standard::copy-name";
    
    /**
     * A key in the "standard" namespace for getting the description of the file.
     * <p>
     * The description is a utf8 string that describes the file, generally containing
     * the filename, but can also contain further information. Example descriptions
     * could be "filename (on hostname)" for a remote file or "filename (in trash)"
     * for a file in the trash. This is useful for instance as the window title
     * when displaying a directory or for a bookmarks menu.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_DESCRIPTION = "standard::description";
    
    /**
     * A key in the "standard" namespace for getting the display name of the file.
     * <p>
     * A display name is guaranteed to be in UTF-8 and can thus be displayed in
     * the UI. It is guaranteed to be set on every file.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME = "standard::display-name";
    
    /**
     * A key in the "standard" namespace for edit name of the file.
     * <p>
     * An edit name is similar to the display name, but it is meant to be
     * used when you want to rename the file in the UI. The display name
     * might contain information you don't want in the new filename (such as
     * "(invalid unicode)" if the filename was in an invalid encoding).
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_EDIT_NAME = "standard::edit-name";
    
    /**
     * A key in the "standard" namespace for getting the fast content type.
     * <p>
     * The fast content type isn't as reliable as the regular one, as it
     * only uses the filename to guess it, but it is faster to calculate than the
     * regular content type.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE = "standard::fast-content-type";
    
    /**
     * A key in the "standard" namespace for getting the icon for the file.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#OBJECT}.
     * <p>
     * The value for this key should contain a {@link Icon}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_ICON = "standard::icon";
    
    /**
     * A key in the "standard" namespace for checking if a file is a backup file.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_IS_BACKUP = "standard::is-backup";
    
    /**
     * A key in the "standard" namespace for checking if a file is hidden.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_IS_HIDDEN = "standard::is-hidden";
    
    /**
     * A key in the "standard" namespace for checking if the file is a symlink.
     * Typically the actual type is something else, if we followed the symlink
     * to get the type.
     * <p>
     * On Windows NTFS mountpoints are considered to be symlinks as well.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_IS_SYMLINK = "standard::is-symlink";
    
    /**
     * A key in the "standard" namespace for checking if a file is virtual.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL = "standard::is-virtual";
    
    /**
     * A key in the "standard" namespace for checking if a file is
     * volatile. This is meant for opaque, non-POSIX-like backends to
     * indicate that the URI is not persistent. Applications should look
     * at {@code G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET} for the persistent URI.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_IS_VOLATILE = "standard::is-volatile";
    
    /**
     * A key in the "standard" namespace for getting the name of the file.
     * <p>
     * The name is the on-disk filename which may not be in any known encoding,
     * and can thus not be generally displayed as is. It is guaranteed to be set on
     * every file.
     * <p>
     * Use {@code G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME} if you need to display the
     * name in a user interface.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BYTE_STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_NAME = "standard::name";
    
    /**
     * A key in the "standard" namespace for getting the file's size (in bytes).
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT64}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_SIZE = "standard::size";
    
    /**
     * A key in the "standard" namespace for setting the sort order of a file.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#INT32}.
     * <p>
     * An example use would be in file managers, which would use this key
     * to set the order files are displayed. Files with smaller sort order
     * should be sorted first, and files without sort order as if sort order
     * was zero.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_SORT_ORDER = "standard::sort-order";
    
    /**
     * A key in the "standard" namespace for getting the symbolic icon for the file.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#OBJECT}.
     * <p>
     * The value for this key should contain a {@link Icon}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON = "standard::symbolic-icon";
    
    /**
     * A key in the "standard" namespace for getting the symlink target, if the file
     * is a symlink.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BYTE_STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET = "standard::symlink-target";
    
    /**
     * A key in the "standard" namespace for getting the target URI for the file, in
     * the case of {@link FileType#SHORTCUT} or {@link FileType#MOUNTABLE} files.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_TARGET_URI = "standard::target-uri";
    
    /**
     * A key in the "standard" namespace for storing file types.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     * <p>
     * The value for this key should contain a {@link FileType}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_STANDARD_TYPE = "standard::type";
    
    /**
     * A key in the "thumbnail" namespace for checking if thumbnailing failed.
     * <p>
     * This attribute is {@code true} if thumbnailing failed.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_THUMBNAILING_FAILED = "thumbnail::failed";
    
    /**
     * A key in the "thumbnail" namespace for checking whether the thumbnail is outdated.
     * <p>
     * This attribute is {@code true} if the thumbnail is up-to-date with the file it represents,
     * and {@code false} if the file has been modified since the thumbnail was generated.
     * <p>
     * If {@code G_FILE_ATTRIBUTE_THUMBNAILING_FAILED} is {@code true} and this attribute is {@code false},
     * it indicates that thumbnailing may be attempted again and may succeed.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_THUMBNAIL_IS_VALID = "thumbnail::is-valid";
    
    /**
     * A key in the "thumbnail" namespace for getting the path to the thumbnail
     * image.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BYTE_STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_THUMBNAIL_PATH = "thumbnail::path";
    
    /**
     * A key in the "time" namespace for getting the time the file was last
     * accessed.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT64}, and
     * contains the time since the file was last accessed, in seconds since the
     * UNIX epoch.
     */
    public static final java.lang.String FILE_ATTRIBUTE_TIME_ACCESS = "time::access";
    
    /**
     * A key in the "time" namespace for getting the nanoseconds of the time
     * the file was last accessed. This should be used in conjunction with
     * {@code G_FILE_ATTRIBUTE_TIME_ACCESS}. Corresponding {@link FileAttributeType} is
     * {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_TIME_ACCESS_NSEC = "time::access-nsec";
    
    /**
     * A key in the "time" namespace for getting the microseconds of the time
     * the file was last accessed.
     * <p>
     * This should be used in conjunction with {@code G_FILE_ATTRIBUTE_TIME_ACCESS}.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_TIME_ACCESS_USEC = "time::access-usec";
    
    /**
     * A key in the "time" namespace for getting the time the file was last
     * changed.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT64},
     * and contains the time since the file was last changed, in seconds since
     * the UNIX epoch.
     * <p>
     * This corresponds to the traditional UNIX ctime.
     */
    public static final java.lang.String FILE_ATTRIBUTE_TIME_CHANGED = "time::changed";
    
    /**
     * A key in the "time" namespace for getting the nanoseconds of the time
     * the file was last changed. This should be used in conjunction with
     * {@code G_FILE_ATTRIBUTE_TIME_CHANGED}. Corresponding {@link FileAttributeType} is
     * {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_TIME_CHANGED_NSEC = "time::changed-nsec";
    
    /**
     * A key in the "time" namespace for getting the microseconds of the time
     * the file was last changed.
     * <p>
     * This should be used in conjunction with {@code G_FILE_ATTRIBUTE_TIME_CHANGED}.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_TIME_CHANGED_USEC = "time::changed-usec";
    
    /**
     * A key in the "time" namespace for getting the time the file was created.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT64},
     * and contains the time since the file was created, in seconds since the UNIX
     * epoch.
     * <p>
     * This may correspond to Linux {@code stx_btime}, FreeBSD {@code st_birthtim}, NetBSD
     * {@code st_birthtime} or NTFS {@code ctime}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_TIME_CREATED = "time::created";
    
    /**
     * A key in the "time" namespace for getting the nanoseconds of the time
     * the file was created. This should be used in conjunction with
     * {@code G_FILE_ATTRIBUTE_TIME_CREATED}. Corresponding {@link FileAttributeType} is
     * {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_TIME_CREATED_NSEC = "time::created-nsec";
    
    /**
     * A key in the "time" namespace for getting the microseconds of the time
     * the file was created.
     * <p>
     * This should be used in conjunction with {@code G_FILE_ATTRIBUTE_TIME_CREATED}.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_TIME_CREATED_USEC = "time::created-usec";
    
    /**
     * A key in the "time" namespace for getting the time the file was last
     * modified.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT64}, and
     * contains the time since the file was modified, in seconds since the UNIX
     * epoch.
     */
    public static final java.lang.String FILE_ATTRIBUTE_TIME_MODIFIED = "time::modified";
    
    /**
     * A key in the "time" namespace for getting the nanoseconds of the time
     * the file was last modified. This should be used in conjunction with
     * {@code G_FILE_ATTRIBUTE_TIME_MODIFIED}. Corresponding {@link FileAttributeType} is
     * {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_TIME_MODIFIED_NSEC = "time::modified-nsec";
    
    /**
     * A key in the "time" namespace for getting the microseconds of the time
     * the file was last modified.
     * <p>
     * This should be used in conjunction with {@code G_FILE_ATTRIBUTE_TIME_MODIFIED}.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_TIME_MODIFIED_USEC = "time::modified-usec";
    
    /**
     * A key in the "trash" namespace for getting the deletion date and time
     * of a file inside the {@code trash:///} folder.
     * <p>
     * The format of the returned string is {@code YYYY-MM-DDThh:mm:ss}.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_TRASH_DELETION_DATE = "trash::deletion-date";
    
    /**
     * A key in the "trash" namespace for getting the number of (toplevel) items
     * that are present in the {@code trash:///} folder.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_TRASH_ITEM_COUNT = "trash::item-count";
    
    /**
     * A key in the "trash" namespace for getting the original path of a file
     * inside the {@code trash:///} folder before it was trashed.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BYTE_STRING}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_TRASH_ORIG_PATH = "trash::orig-path";
    
    /**
     * A key in the "unix" namespace for getting the number of blocks allocated
     * for the file.
     * <p>
     * This attribute is only available for UNIX file systems.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT64}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_UNIX_BLOCKS = "unix::blocks";
    
    /**
     * A key in the "unix" namespace for getting the block size for the file
     * system.
     * <p>
     * This attribute is only available for UNIX file systems.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_UNIX_BLOCK_SIZE = "unix::block-size";
    
    /**
     * A key in the "unix" namespace for getting the device id of the device the
     * file is located on (see stat() documentation).
     * <p>
     * This attribute is only available for UNIX file systems.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_UNIX_DEVICE = "unix::device";
    
    /**
     * A key in the "unix" namespace for getting the group ID for the file.
     * <p>
     * This attribute is only available for UNIX file systems.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_UNIX_GID = "unix::gid";
    
    /**
     * A key in the "unix" namespace for getting the inode of the file.
     * <p>
     * This attribute is only available for UNIX file systems.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT64}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_UNIX_INODE = "unix::inode";
    
    /**
     * A key in the "unix" namespace for checking if the file represents a
     * UNIX mount point.
     * <p>
     * This attribute is {@code true} if the file is a UNIX mount point.
     * <p>
     * Since 2.58, {@code /} is considered to be a mount point.
     * <p>
     * This attribute is only available for UNIX file systems.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#BOOLEAN}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT = "unix::is-mountpoint";
    
    /**
     * A key in the "unix" namespace for getting the mode of the file
     * (e.g. whether the file is a regular file, symlink, etc).
     * <p>
     * See the documentation for {@code lstat()}: this attribute is equivalent to
     * the {@code st_mode} member of {@code struct stat}, and includes both the file type
     * and permissions.
     * <p>
     * This attribute is only available for UNIX file systems.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_UNIX_MODE = "unix::mode";
    
    /**
     * A key in the "unix" namespace for getting the number of hard links
     * for a file.
     * <p>
     * See the documentation for {@code lstat()}.
     * <p>
     * This attribute is only available for UNIX file systems.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_UNIX_NLINK = "unix::nlink";
    
    /**
     * A key in the "unix" namespace for getting the device ID for the file
     * (if it is a special file).
     * <p>
     * See the documentation for {@code lstat()}.
     * <p>
     * This attribute is only available for UNIX file systems.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_UNIX_RDEV = "unix::rdev";
    
    /**
     * A key in the "unix" namespace for getting the user ID for the file.
     * <p>
     * This attribute is only available for UNIX file systems.
     * <p>
     * Corresponding {@link FileAttributeType} is {@link FileAttributeType#UINT32}.
     */
    public static final java.lang.String FILE_ATTRIBUTE_UNIX_UID = "unix::uid";
    
    /**
     * Extension point for memory usage monitoring functionality.
     * See [Extending GIO][extending-gio].
     */
    public static final java.lang.String MEMORY_MONITOR_EXTENSION_POINT_NAME = "gio-memory-monitor";
    
    /**
     * The menu item attribute which holds the action name of the item.  Action
     * names are namespaced with an identifier for the action group in which the
     * action resides. For example, "win." for window-specific actions and "app."
     * for application-wide actions.
     * <p>
     * See also g_menu_model_get_item_attribute() and g_menu_item_set_attribute().
     */
    public static final java.lang.String MENU_ATTRIBUTE_ACTION = "action";
    
    /**
     * The menu item attribute that holds the namespace for all action names in
     * menus that are linked from this item.
     */
    public static final java.lang.String MENU_ATTRIBUTE_ACTION_NAMESPACE = "action-namespace";
    
    /**
     * The menu item attribute which holds the icon of the item.
     * <p>
     * The icon is stored in the format returned by g_icon_serialize().
     * <p>
     * This attribute is intended only to represent 'noun' icons such as
     * favicons for a webpage, or application icons.  It should not be used
     * for 'verbs' (ie: stock icons).
     */
    public static final java.lang.String MENU_ATTRIBUTE_ICON = "icon";
    
    /**
     * The menu item attribute which holds the label of the item.
     */
    public static final java.lang.String MENU_ATTRIBUTE_LABEL = "label";
    
    /**
     * The menu item attribute which holds the target with which the item's action
     * will be activated.
     * <p>
     * See also g_menu_item_set_action_and_target()
     */
    public static final java.lang.String MENU_ATTRIBUTE_TARGET = "target";
    
    /**
     * The name of the link that associates a menu item with a section.  The linked
     * menu will usually be shown in place of the menu item, using the item's label
     * as a header.
     * <p>
     * See also g_menu_item_set_link().
     */
    public static final java.lang.String MENU_LINK_SECTION = "section";
    
    /**
     * The name of the link that associates a menu item with a submenu.
     * <p>
     * See also g_menu_item_set_link().
     */
    public static final java.lang.String MENU_LINK_SUBMENU = "submenu";
    
    public static final java.lang.String NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME = "gio-native-volume-monitor";
    
    /**
     * Extension point for network status monitoring functionality.
     * See [Extending GIO][extending-gio].
     */
    public static final java.lang.String NETWORK_MONITOR_EXTENSION_POINT_NAME = "gio-network-monitor";
    
    /**
     * Extension point for power profile usage monitoring functionality.
     * See [Extending GIO][extending-gio].
     */
    public static final java.lang.String POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME = "gio-power-profile-monitor";
    
    /**
     * Extension point for proxy functionality.
     * See [Extending GIO][extending-gio].
     */
    public static final java.lang.String PROXY_EXTENSION_POINT_NAME = "gio-proxy";
    
    /**
     * Extension point for proxy resolving functionality.
     * See [Extending GIO][extending-gio].
     */
    public static final java.lang.String PROXY_RESOLVER_EXTENSION_POINT_NAME = "gio-proxy-resolver";
    
    /**
     * Extension point for {@link SettingsBackend} functionality.
     */
    public static final java.lang.String SETTINGS_BACKEND_EXTENSION_POINT_NAME = "gsettings-backend";
    
    /**
     * Extension point for TLS functionality via {@link TlsBackend}.
     * See [Extending GIO][extending-gio].
     */
    public static final java.lang.String TLS_BACKEND_EXTENSION_POINT_NAME = "gio-tls-backend";
    
    /**
     * The purpose used to verify the client certificate in a TLS connection.
     * Used by TLS servers.
     */
    public static final java.lang.String TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT = "1.3.6.1.5.5.7.3.2";
    
    /**
     * The purpose used to verify the server certificate in a TLS connection. This
     * is the most common purpose in use. Used by TLS clients.
     */
    public static final java.lang.String TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER = "1.3.6.1.5.5.7.3.1";
    
    /**
     * Extension point for {@link Vfs} functionality.
     * See [Extending GIO][extending-gio].
     */
    public static final java.lang.String VFS_EXTENSION_POINT_NAME = "gio-vfs";
    
    /**
     * The string used to obtain the volume class with g_volume_get_identifier().
     * <p>
     * Known volume classes include {@code device}, {@code network}, and {@code loop}. Other
     * classes may be added in the future.
     * <p>
     * This is intended to be used by applications to classify {@link Volume}
     * instances into different sections - for example a file manager or
     * file chooser can use this information to show {@code network} volumes under
     * a "Network" heading and {@code device} volumes under a "Devices" heading.
     */
    public static final java.lang.String VOLUME_IDENTIFIER_KIND_CLASS = "class";
    
    /**
     * The string used to obtain a Hal UDI with g_volume_get_identifier().
     */
    public static final java.lang.String VOLUME_IDENTIFIER_KIND_HAL_UDI = "hal-udi";
    
    /**
     * The string used to obtain a filesystem label with g_volume_get_identifier().
     */
    public static final java.lang.String VOLUME_IDENTIFIER_KIND_LABEL = "label";
    
    /**
     * The string used to obtain a NFS mount with g_volume_get_identifier().
     */
    public static final java.lang.String VOLUME_IDENTIFIER_KIND_NFS_MOUNT = "nfs-mount";
    
    /**
     * The string used to obtain a Unix device path with g_volume_get_identifier().
     */
    public static final java.lang.String VOLUME_IDENTIFIER_KIND_UNIX_DEVICE = "unix-device";
    
    /**
     * The string used to obtain a UUID with g_volume_get_identifier().
     */
    public static final java.lang.String VOLUME_IDENTIFIER_KIND_UUID = "uuid";
    
    /**
     * Extension point for volume monitor functionality.
     * See [Extending GIO][extending-gio].
     */
    public static final java.lang.String VOLUME_MONITOR_EXTENSION_POINT_NAME = "gio-volume-monitor";
    
    /**
     * Checks if {@code action_name} is valid.
     * <p>
     * {@code action_name} is valid if it consists only of alphanumeric characters,
     * plus '-' and '.'.  The empty string is not a valid action name.
     * <p>
     * It is an error to call this function with a non-utf8 {@code action_name}.
     * {@code action_name} must not be {@code null}.
     * @param actionName a potential action name
     * @return {@code true} if {@code action_name} is valid
     */
    public static boolean actionNameIsValid(@NotNull java.lang.String actionName) {
        java.util.Objects.requireNonNull(actionName, "Parameter 'actionName' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_action_name_is_valid.invokeExact(
                    Interop.allocateNativeString(actionName));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Parses a detailed action name into its separate name and target
     * components.
     * <p>
     * Detailed action names can have three formats.
     * <p>
     * The first format is used to represent an action name with no target
     * value and consists of just an action name containing no whitespace
     * nor the characters ':', '(' or ')'.  For example: "app.action".
     * <p>
     * The second format is used to represent an action with a target value
     * that is a non-empty string consisting only of alphanumerics, plus '-'
     * and '.'.  In that case, the action name and target value are
     * separated by a double colon ("::").  For example:
     * "app.action::target".
     * <p>
     * The third format is used to represent an action with any type of
     * target value, including strings.  The target value follows the action
     * name, surrounded in parens.  For example: "app.action(42)".  The
     * target value is parsed using g_variant_parse().  If a tuple-typed
     * value is desired, it must be specified in the same way, resulting in
     * two sets of parens, for example: "app.action((1,2,3))".  A string
     * target can be specified this way as well: "app.action('target')".
     * For strings, this third format must be used if * target value is
     * empty or contains characters other than alphanumerics, '-' and '.'.
     * @param detailedName a detailed action name
     * @param actionName the action name
     * @param targetValue the target value, or {@code null} for no target
     * @return {@code true} if successful, else {@code false} with {@code error} set
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static boolean actionParseDetailedName(@NotNull java.lang.String detailedName, @NotNull Out<java.lang.String> actionName, @NotNull PointerProxy<org.gtk.glib.Variant> targetValue) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(detailedName, "Parameter 'detailedName' must not be null");
        java.util.Objects.requireNonNull(actionName, "Parameter 'actionName' must not be null");
        MemorySegment actionNamePOINTER = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        java.util.Objects.requireNonNull(targetValue, "Parameter 'targetValue' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_action_parse_detailed_name.invokeExact(
                    Interop.allocateNativeString(detailedName),
                    (Addressable) actionNamePOINTER.address(),
                    targetValue.handle(),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        actionName.set(Interop.getStringFrom(actionNamePOINTER.get(Interop.valueLayout.ADDRESS, 0)));
        return RESULT != 0;
    }
    
    /**
     * Formats a detailed action name from {@code action_name} and {@code target_value}.
     * <p>
     * It is an error to call this function with an invalid action name.
     * <p>
     * This function is the opposite of g_action_parse_detailed_name().
     * It will produce a string that can be parsed back to the {@code action_name}
     * and {@code target_value} by that function.
     * <p>
     * See that function for the types of strings that will be printed by
     * this function.
     * @param actionName a valid action name
     * @param targetValue a {@link org.gtk.glib.Variant} target value, or {@code null}
     * @return a detailed format string
     */
    public static @NotNull java.lang.String actionPrintDetailedName(@NotNull java.lang.String actionName, @Nullable org.gtk.glib.Variant targetValue) {
        java.util.Objects.requireNonNull(actionName, "Parameter 'actionName' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_action_print_detailed_name.invokeExact(
                    Interop.allocateNativeString(actionName),
                    (Addressable) (targetValue == null ? MemoryAddress.NULL : targetValue.handle()));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Creates a new {@link AppInfo} from the given information.
     * <p>
     * Note that for {@code commandline}, the quoting rules of the Exec key of the
     * <a href="http://freedesktop.org/Standards/desktop-entry-spec">freedesktop.org Desktop Entry Specification</a>
     * are applied. For example, if the {@code commandline} contains
     * percent-encoded URIs, the percent-character must be doubled in order to prevent it from
     * being swallowed by Exec key unquoting. See the specification for exact quoting rules.
     * @param commandline the commandline to use
     * @param applicationName the application name, or {@code null} to use {@code commandline}
     * @param flags flags that can specify details of the created {@link AppInfo}
     * @return new {@link AppInfo} for given command.
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.AppInfo appInfoCreateFromCommandline(@NotNull java.lang.String commandline, @Nullable java.lang.String applicationName, @NotNull org.gtk.gio.AppInfoCreateFlags flags) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(commandline, "Parameter 'commandline' must not be null");
        java.util.Objects.requireNonNull(flags, "Parameter 'flags' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_app_info_create_from_commandline.invokeExact(
                    Interop.allocateNativeString(commandline),
                    (Addressable) (applicationName == null ? MemoryAddress.NULL : Interop.allocateNativeString(applicationName)),
                    flags.getValue(),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.AppInfo.AppInfoImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Gets a list of all of the applications currently registered
     * on this system.
     * <p>
     * For desktop files, this includes applications that have
     * {@code NoDisplay=true} set or are excluded from display by means
     * of {@code OnlyShowIn} or {@code NotShowIn}. See g_app_info_should_show().
     * The returned list does not include applications which have
     * the {@code Hidden} key set.
     * @return a newly allocated {@link org.gtk.glib.List} of references to {@code GAppInfos}.
     */
    public static @NotNull org.gtk.glib.List appInfoGetAll() {
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_app_info_get_all.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.List(RESULT, Ownership.FULL);
    }
    
    /**
     * Gets a list of all {@code GAppInfos} for a given content type,
     * including the recommended and fallback {@code GAppInfos}. See
     * g_app_info_get_recommended_for_type() and
     * g_app_info_get_fallback_for_type().
     * @param contentType the content type to find a {@link AppInfo} for
     * @return {@link org.gtk.glib.List} of {@code GAppInfos}
     *     for given {@code content_type} or {@code null} on error.
     */
    public static @NotNull org.gtk.glib.List appInfoGetAllForType(@NotNull java.lang.String contentType) {
        java.util.Objects.requireNonNull(contentType, "Parameter 'contentType' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_app_info_get_all_for_type.invokeExact(
                    Interop.allocateNativeString(contentType));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.List(RESULT, Ownership.FULL);
    }
    
    /**
     * Gets the default {@link AppInfo} for a given content type.
     * @param contentType the content type to find a {@link AppInfo} for
     * @param mustSupportUris if {@code true}, the {@link AppInfo} is expected to
     *     support URIs
     * @return {@link AppInfo} for given {@code content_type} or
     *     {@code null} on error.
     */
    public static @Nullable org.gtk.gio.AppInfo appInfoGetDefaultForType(@NotNull java.lang.String contentType, boolean mustSupportUris) {
        java.util.Objects.requireNonNull(contentType, "Parameter 'contentType' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_app_info_get_default_for_type.invokeExact(
                    Interop.allocateNativeString(contentType),
                    mustSupportUris ? 1 : 0);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.AppInfo.AppInfoImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Asynchronously gets the default {@link AppInfo} for a given content type.
     * @param contentType the content type to find a {@link AppInfo} for
     * @param mustSupportUris if {@code true}, the {@link AppInfo} is expected to
     *     support URIs
     * @param cancellable optional {@link Cancellable} object, {@code null} to ignore
     * @param callback a {@link AsyncReadyCallback} to call when the request is done
     */
    public static void appInfoGetDefaultForTypeAsync(@NotNull java.lang.String contentType, boolean mustSupportUris, @Nullable org.gtk.gio.Cancellable cancellable, @Nullable org.gtk.gio.AsyncReadyCallback callback) {
        java.util.Objects.requireNonNull(contentType, "Parameter 'contentType' must not be null");
        try {
            DowncallHandles.g_app_info_get_default_for_type_async.invokeExact(
                    Interop.allocateNativeString(contentType),
                    mustSupportUris ? 1 : 0,
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()),
                    (Addressable) (callback == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbAsyncReadyCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (callback == null ? MemoryAddress.NULL : Interop.registerCallback(callback)));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Finishes a default {@link AppInfo} lookup started by
     * g_app_info_get_default_for_type_async().
     * <p>
     * If no {@link AppInfo} is found, then {@code error} will be set to {@link IOErrorEnum#NOT_FOUND}.
     * @param result a {@link AsyncResult}
     * @return {@link AppInfo} for given {@code content_type} or
     *     {@code null} on error.
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.AppInfo appInfoGetDefaultForTypeFinish(@NotNull org.gtk.gio.AsyncResult result) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(result, "Parameter 'result' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_app_info_get_default_for_type_finish.invokeExact(
                    result.handle(),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.AppInfo.AppInfoImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Gets the default application for handling URIs with
     * the given URI scheme. A URI scheme is the initial part
     * of the URI, up to but not including the ':', e.g. "http",
     * "ftp" or "sip".
     * @param uriScheme a string containing a URI scheme.
     * @return {@link AppInfo} for given {@code uri_scheme} or
     *     {@code null} on error.
     */
    public static @Nullable org.gtk.gio.AppInfo appInfoGetDefaultForUriScheme(@NotNull java.lang.String uriScheme) {
        java.util.Objects.requireNonNull(uriScheme, "Parameter 'uriScheme' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_app_info_get_default_for_uri_scheme.invokeExact(
                    Interop.allocateNativeString(uriScheme));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.AppInfo.AppInfoImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Asynchronously gets the default application for handling URIs with
     * the given URI scheme. A URI scheme is the initial part
     * of the URI, up to but not including the ':', e.g. "http",
     * "ftp" or "sip".
     * @param uriScheme a string containing a URI scheme.
     * @param cancellable optional {@link Cancellable} object, {@code null} to ignore
     * @param callback a {@link AsyncReadyCallback} to call when the request is done
     */
    public static void appInfoGetDefaultForUriSchemeAsync(@NotNull java.lang.String uriScheme, @Nullable org.gtk.gio.Cancellable cancellable, @Nullable org.gtk.gio.AsyncReadyCallback callback) {
        java.util.Objects.requireNonNull(uriScheme, "Parameter 'uriScheme' must not be null");
        try {
            DowncallHandles.g_app_info_get_default_for_uri_scheme_async.invokeExact(
                    Interop.allocateNativeString(uriScheme),
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()),
                    (Addressable) (callback == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbAsyncReadyCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (callback == null ? MemoryAddress.NULL : Interop.registerCallback(callback)));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Finishes a default {@link AppInfo} lookup started by
     * g_app_info_get_default_for_uri_scheme_async().
     * <p>
     * If no {@link AppInfo} is found, then {@code error} will be set to {@link IOErrorEnum#NOT_FOUND}.
     * @param result a {@link AsyncResult}
     * @return {@link AppInfo} for given {@code uri_scheme} or
     *     {@code null} on error.
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.AppInfo appInfoGetDefaultForUriSchemeFinish(@NotNull org.gtk.gio.AsyncResult result) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(result, "Parameter 'result' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_app_info_get_default_for_uri_scheme_finish.invokeExact(
                    result.handle(),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.AppInfo.AppInfoImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Gets a list of fallback {@code GAppInfos} for a given content type, i.e.
     * those applications which claim to support the given content type
     * by MIME type subclassing and not directly.
     * @param contentType the content type to find a {@link AppInfo} for
     * @return {@link org.gtk.glib.List} of {@code GAppInfos}
     *     for given {@code content_type} or {@code null} on error.
     */
    public static @NotNull org.gtk.glib.List appInfoGetFallbackForType(@NotNull java.lang.String contentType) {
        java.util.Objects.requireNonNull(contentType, "Parameter 'contentType' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_app_info_get_fallback_for_type.invokeExact(
                    Interop.allocateNativeString(contentType));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.List(RESULT, Ownership.FULL);
    }
    
    /**
     * Gets a list of recommended {@code GAppInfos} for a given content type, i.e.
     * those applications which claim to support the given content type exactly,
     * and not by MIME type subclassing.
     * Note that the first application of the list is the last used one, i.e.
     * the last one for which g_app_info_set_as_last_used_for_type() has been
     * called.
     * @param contentType the content type to find a {@link AppInfo} for
     * @return {@link org.gtk.glib.List} of {@code GAppInfos}
     *     for given {@code content_type} or {@code null} on error.
     */
    public static @NotNull org.gtk.glib.List appInfoGetRecommendedForType(@NotNull java.lang.String contentType) {
        java.util.Objects.requireNonNull(contentType, "Parameter 'contentType' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_app_info_get_recommended_for_type.invokeExact(
                    Interop.allocateNativeString(contentType));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.List(RESULT, Ownership.FULL);
    }
    
    /**
     * Utility function that launches the default application
     * registered to handle the specified uri. Synchronous I/O
     * is done on the uri to detect the type of the file if
     * required.
     * <p>
     * The D-Busactivated applications don't have to be started if your application
     * terminates too soon after this function. To prevent this, use
     * g_app_info_launch_default_for_uri_async() instead.
     * @param uri the uri to show
     * @param context an optional {@link AppLaunchContext}
     * @return {@code true} on success, {@code false} on error.
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static boolean appInfoLaunchDefaultForUri(@NotNull java.lang.String uri, @Nullable org.gtk.gio.AppLaunchContext context) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(uri, "Parameter 'uri' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_app_info_launch_default_for_uri.invokeExact(
                    Interop.allocateNativeString(uri),
                    (Addressable) (context == null ? MemoryAddress.NULL : context.handle()),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return RESULT != 0;
    }
    
    /**
     * Async version of g_app_info_launch_default_for_uri().
     * <p>
     * This version is useful if you are interested in receiving
     * error information in the case where the application is
     * sandboxed and the portal may present an application chooser
     * dialog to the user.
     * <p>
     * This is also useful if you want to be sure that the D-Busactivated
     * applications are really started before termination and if you are interested
     * in receiving error information from their activation.
     * @param uri the uri to show
     * @param context an optional {@link AppLaunchContext}
     * @param cancellable a {@link Cancellable}
     * @param callback a {@link AsyncReadyCallback} to call when the request is done
     */
    public static void appInfoLaunchDefaultForUriAsync(@NotNull java.lang.String uri, @Nullable org.gtk.gio.AppLaunchContext context, @Nullable org.gtk.gio.Cancellable cancellable, @Nullable org.gtk.gio.AsyncReadyCallback callback) {
        java.util.Objects.requireNonNull(uri, "Parameter 'uri' must not be null");
        try {
            DowncallHandles.g_app_info_launch_default_for_uri_async.invokeExact(
                    Interop.allocateNativeString(uri),
                    (Addressable) (context == null ? MemoryAddress.NULL : context.handle()),
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()),
                    (Addressable) (callback == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbAsyncReadyCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (callback == null ? MemoryAddress.NULL : Interop.registerCallback(callback)));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Finishes an asynchronous launch-default-for-uri operation.
     * @param result a {@link AsyncResult}
     * @return {@code true} if the launch was successful, {@code false} if {@code error} is set
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static boolean appInfoLaunchDefaultForUriFinish(@NotNull org.gtk.gio.AsyncResult result) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(result, "Parameter 'result' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_app_info_launch_default_for_uri_finish.invokeExact(
                    result.handle(),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return RESULT != 0;
    }
    
    /**
     * Removes all changes to the type associations done by
     * g_app_info_set_as_default_for_type(),
     * g_app_info_set_as_default_for_extension(),
     * g_app_info_add_supports_type() or
     * g_app_info_remove_supports_type().
     * @param contentType a content type
     */
    public static void appInfoResetTypeAssociations(@NotNull java.lang.String contentType) {
        java.util.Objects.requireNonNull(contentType, "Parameter 'contentType' must not be null");
        try {
            DowncallHandles.g_app_info_reset_type_associations.invokeExact(
                    Interop.allocateNativeString(contentType));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Helper function for constructing {@link AsyncInitable} object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     * <p>
     * When the initialization is finished, {@code callback} will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     * @param objectType a {@link org.gtk.gobject.Type} supporting {@link AsyncInitable}.
     * @param nParameters the number of parameters in {@code parameters}
     * @param parameters the parameters to use to construct the object
     * @param ioPriority the [I/O priority][io-priority] of the operation
     * @param cancellable optional {@link Cancellable} object, {@code null} to ignore.
     * @param callback a {@link AsyncReadyCallback} to call when the initialization is
     *     finished
     * @deprecated Use g_object_new_with_properties() and
     * g_async_initable_init_async() instead. See {@link org.gtk.gobject.Parameter} for more information.
     */
    @Deprecated
    public static void asyncInitableNewvAsync(@NotNull org.gtk.glib.Type objectType, int nParameters, @NotNull org.gtk.gobject.Parameter parameters, int ioPriority, @Nullable org.gtk.gio.Cancellable cancellable, @Nullable org.gtk.gio.AsyncReadyCallback callback) {
        java.util.Objects.requireNonNull(objectType, "Parameter 'objectType' must not be null");
        java.util.Objects.requireNonNull(parameters, "Parameter 'parameters' must not be null");
        try {
            DowncallHandles.g_async_initable_newv_async.invokeExact(
                    objectType.getValue().longValue(),
                    nParameters,
                    parameters.handle(),
                    ioPriority,
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()),
                    (Addressable) (callback == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbAsyncReadyCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (callback == null ? MemoryAddress.NULL : Interop.registerCallback(callback)));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Asynchronously connects to the message bus specified by {@code bus_type}.
     * <p>
     * When the operation is finished, {@code callback} will be invoked. You can
     * then call g_bus_get_finish() to get the result of the operation.
     * <p>
     * This is an asynchronous failable function. See g_bus_get_sync() for
     * the synchronous version.
     * @param busType a {@link BusType}
     * @param cancellable a {@link Cancellable} or {@code null}
     * @param callback a {@link AsyncReadyCallback} to call when the request is satisfied
     */
    public static void busGet(@NotNull org.gtk.gio.BusType busType, @Nullable org.gtk.gio.Cancellable cancellable, @Nullable org.gtk.gio.AsyncReadyCallback callback) {
        java.util.Objects.requireNonNull(busType, "Parameter 'busType' must not be null");
        try {
            DowncallHandles.g_bus_get.invokeExact(
                    busType.getValue(),
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()),
                    (Addressable) (callback == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbAsyncReadyCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (callback == null ? MemoryAddress.NULL : Interop.registerCallback(callback)));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Finishes an operation started with g_bus_get().
     * <p>
     * The returned object is a singleton, that is, shared with other
     * callers of g_bus_get() and g_bus_get_sync() for {@code bus_type}. In the
     * event that you need a private message bus connection, use
     * g_dbus_address_get_for_bus_sync() and
     * g_dbus_connection_new_for_address() with
     * G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
     * G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
     * <p>
     * Note that the returned {@link DBusConnection} object will (usually) have
     * the {@link DBusConnection}:exit-on-close property set to {@code true}.
     * @param res a {@link AsyncResult} obtained from the {@link AsyncReadyCallback} passed
     *     to g_bus_get()
     * @return a {@link DBusConnection} or {@code null} if {@code error} is set.
     *     Free with g_object_unref().
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.DBusConnection busGetFinish(@NotNull org.gtk.gio.AsyncResult res) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(res, "Parameter 'res' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_bus_get_finish.invokeExact(
                    res.handle(),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.DBusConnection(RESULT, Ownership.FULL);
    }
    
    /**
     * Synchronously connects to the message bus specified by {@code bus_type}.
     * Note that the returned object may shared with other callers,
     * e.g. if two separate parts of a process calls this function with
     * the same {@code bus_type}, they will share the same object.
     * <p>
     * This is a synchronous failable function. See g_bus_get() and
     * g_bus_get_finish() for the asynchronous version.
     * <p>
     * The returned object is a singleton, that is, shared with other
     * callers of g_bus_get() and g_bus_get_sync() for {@code bus_type}. In the
     * event that you need a private message bus connection, use
     * g_dbus_address_get_for_bus_sync() and
     * g_dbus_connection_new_for_address() with
     * G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
     * G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
     * <p>
     * Note that the returned {@link DBusConnection} object will (usually) have
     * the {@link DBusConnection}:exit-on-close property set to {@code true}.
     * @param busType a {@link BusType}
     * @param cancellable a {@link Cancellable} or {@code null}
     * @return a {@link DBusConnection} or {@code null} if {@code error} is set.
     *     Free with g_object_unref().
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.DBusConnection busGetSync(@NotNull org.gtk.gio.BusType busType, @Nullable org.gtk.gio.Cancellable cancellable) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(busType, "Parameter 'busType' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_bus_get_sync.invokeExact(
                    busType.getValue(),
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.DBusConnection(RESULT, Ownership.FULL);
    }
    
    /**
     * Starts acquiring {@code name} on the bus specified by {@code bus_type} and calls
     * {@code name_acquired_handler} and {@code name_lost_handler} when the name is
     * acquired respectively lost. Callbacks will be invoked in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread you are calling this function from.
     * <p>
     * You are guaranteed that one of the {@code name_acquired_handler} and {@code name_lost_handler}
     * callbacks will be invoked after calling this function - there are three
     * possible cases:
     * <ul>
     * <li>{@code name_lost_handler} with a {@code null} connection (if a connection to the bus
     *   can't be made).
     * </ul>
     * <ul>
     * <li>{@code bus_acquired_handler} then {@code name_lost_handler} (if the name can't be
     *   obtained)
     * </ul>
     * <ul>
     * <li>{@code bus_acquired_handler} then {@code name_acquired_handler} (if the name was
     *   obtained).
     * </ul>
     * <p>
     * When you are done owning the name, just call g_bus_unown_name()
     * with the owner id this function returns.
     * <p>
     * If the name is acquired or lost (for example another application
     * could acquire the name if you allow replacement or the application
     * currently owning the name exits), the handlers are also invoked.
     * If the {@link DBusConnection} that is used for attempting to own the name
     * closes, then {@code name_lost_handler} is invoked since it is no longer
     * possible for other processes to access the process.
     * <p>
     * You cannot use g_bus_own_name() several times for the same name (unless
     * interleaved with calls to g_bus_unown_name()) - only the first call
     * will work.
     * <p>
     * Another guarantee is that invocations of {@code name_acquired_handler}
     * and {@code name_lost_handler} are guaranteed to alternate; that
     * is, if {@code name_acquired_handler} is invoked then you are
     * guaranteed that the next time one of the handlers is invoked, it
     * will be {@code name_lost_handler}. The reverse is also true.
     * <p>
     * If you plan on exporting objects (using e.g.
     * g_dbus_connection_register_object()), note that it is generally too late
     * to export the objects in {@code name_acquired_handler}. Instead, you can do this
     * in {@code bus_acquired_handler} since you are guaranteed that this will run
     * before {@code name} is requested from the bus.
     * <p>
     * This behavior makes it very simple to write applications that wants
     * to [own names][gdbus-owning-names] and export objects.
     * Simply register objects to be exported in {@code bus_acquired_handler} and
     * unregister the objects (if any) in {@code name_lost_handler}.
     * @param busType the type of bus to own a name on
     * @param name the well-known name to own
     * @param flags a set of flags from the {@link BusNameOwnerFlags} enumeration
     * @param busAcquiredHandler handler to invoke when connected to the bus of type {@code bus_type} or {@code null}
     * @param nameAcquiredHandler handler to invoke when {@code name} is acquired or {@code null}
     * @param nameLostHandler handler to invoke when {@code name} is lost or {@code null}
     * @return an identifier (never 0) that can be used with
     *     g_bus_unown_name() to stop owning the name.
     */
    public static int busOwnName(@NotNull org.gtk.gio.BusType busType, @NotNull java.lang.String name, @NotNull org.gtk.gio.BusNameOwnerFlags flags, @Nullable org.gtk.gio.BusAcquiredCallback busAcquiredHandler, @Nullable org.gtk.gio.BusNameAcquiredCallback nameAcquiredHandler, @Nullable org.gtk.gio.BusNameLostCallback nameLostHandler) {
        java.util.Objects.requireNonNull(busType, "Parameter 'busType' must not be null");
        java.util.Objects.requireNonNull(name, "Parameter 'name' must not be null");
        java.util.Objects.requireNonNull(flags, "Parameter 'flags' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_bus_own_name.invokeExact(
                    busType.getValue(),
                    Interop.allocateNativeString(name),
                    flags.getValue(),
                    (Addressable) (busAcquiredHandler == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbBusAcquiredCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (nameAcquiredHandler == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbBusNameAcquiredCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (nameLostHandler == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbBusNameLostCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (busAcquiredHandler == null ? MemoryAddress.NULL : Interop.registerCallback(busAcquiredHandler)),
                    Interop.cbDestroyNotifySymbol());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT;
    }
    
    /**
     * Like g_bus_own_name() but takes a {@link DBusConnection} instead of a
     * {@link BusType}.
     * @param connection a {@link DBusConnection}
     * @param name the well-known name to own
     * @param flags a set of flags from the {@link BusNameOwnerFlags} enumeration
     * @param nameAcquiredHandler handler to invoke when {@code name} is acquired or {@code null}
     * @param nameLostHandler handler to invoke when {@code name} is lost or {@code null}
     * @return an identifier (never 0) that can be used with
     *     g_bus_unown_name() to stop owning the name
     */
    public static int busOwnNameOnConnection(@NotNull org.gtk.gio.DBusConnection connection, @NotNull java.lang.String name, @NotNull org.gtk.gio.BusNameOwnerFlags flags, @Nullable org.gtk.gio.BusNameAcquiredCallback nameAcquiredHandler, @Nullable org.gtk.gio.BusNameLostCallback nameLostHandler) {
        java.util.Objects.requireNonNull(connection, "Parameter 'connection' must not be null");
        java.util.Objects.requireNonNull(name, "Parameter 'name' must not be null");
        java.util.Objects.requireNonNull(flags, "Parameter 'flags' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_bus_own_name_on_connection.invokeExact(
                    connection.handle(),
                    Interop.allocateNativeString(name),
                    flags.getValue(),
                    (Addressable) (nameAcquiredHandler == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbBusNameAcquiredCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (nameLostHandler == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbBusNameLostCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (nameAcquiredHandler == null ? MemoryAddress.NULL : Interop.registerCallback(nameAcquiredHandler)),
                    Interop.cbDestroyNotifySymbol());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT;
    }
    
    /**
     * Version of g_bus_own_name_on_connection() using closures instead of
     * callbacks for easier binding in other languages.
     * @param connection a {@link DBusConnection}
     * @param name the well-known name to own
     * @param flags a set of flags from the {@link BusNameOwnerFlags} enumeration
     * @param nameAcquiredClosure {@link org.gtk.gobject.Closure} to invoke when {@code name} is
     *     acquired or {@code null}
     * @param nameLostClosure {@link org.gtk.gobject.Closure} to invoke when {@code name} is lost
     *     or {@code null}
     * @return an identifier (never 0) that can be used with
     *     g_bus_unown_name() to stop owning the name.
     */
    public static int busOwnNameOnConnectionWithClosures(@NotNull org.gtk.gio.DBusConnection connection, @NotNull java.lang.String name, @NotNull org.gtk.gio.BusNameOwnerFlags flags, @Nullable org.gtk.gobject.Closure nameAcquiredClosure, @Nullable org.gtk.gobject.Closure nameLostClosure) {
        java.util.Objects.requireNonNull(connection, "Parameter 'connection' must not be null");
        java.util.Objects.requireNonNull(name, "Parameter 'name' must not be null");
        java.util.Objects.requireNonNull(flags, "Parameter 'flags' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_bus_own_name_on_connection_with_closures.invokeExact(
                    connection.handle(),
                    Interop.allocateNativeString(name),
                    flags.getValue(),
                    (Addressable) (nameAcquiredClosure == null ? MemoryAddress.NULL : nameAcquiredClosure.handle()),
                    (Addressable) (nameLostClosure == null ? MemoryAddress.NULL : nameLostClosure.handle()));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT;
    }
    
    /**
     * Version of g_bus_own_name() using closures instead of callbacks for
     * easier binding in other languages.
     * @param busType the type of bus to own a name on
     * @param name the well-known name to own
     * @param flags a set of flags from the {@link BusNameOwnerFlags} enumeration
     * @param busAcquiredClosure {@link org.gtk.gobject.Closure} to invoke when connected to
     *     the bus of type {@code bus_type} or {@code null}
     * @param nameAcquiredClosure {@link org.gtk.gobject.Closure} to invoke when {@code name} is
     *     acquired or {@code null}
     * @param nameLostClosure {@link org.gtk.gobject.Closure} to invoke when {@code name} is lost or
     *     {@code null}
     * @return an identifier (never 0) that can be used with
     *     g_bus_unown_name() to stop owning the name.
     */
    public static int busOwnNameWithClosures(@NotNull org.gtk.gio.BusType busType, @NotNull java.lang.String name, @NotNull org.gtk.gio.BusNameOwnerFlags flags, @Nullable org.gtk.gobject.Closure busAcquiredClosure, @Nullable org.gtk.gobject.Closure nameAcquiredClosure, @Nullable org.gtk.gobject.Closure nameLostClosure) {
        java.util.Objects.requireNonNull(busType, "Parameter 'busType' must not be null");
        java.util.Objects.requireNonNull(name, "Parameter 'name' must not be null");
        java.util.Objects.requireNonNull(flags, "Parameter 'flags' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_bus_own_name_with_closures.invokeExact(
                    busType.getValue(),
                    Interop.allocateNativeString(name),
                    flags.getValue(),
                    (Addressable) (busAcquiredClosure == null ? MemoryAddress.NULL : busAcquiredClosure.handle()),
                    (Addressable) (nameAcquiredClosure == null ? MemoryAddress.NULL : nameAcquiredClosure.handle()),
                    (Addressable) (nameLostClosure == null ? MemoryAddress.NULL : nameLostClosure.handle()));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT;
    }
    
    /**
     * Stops owning a name.
     * <p>
     * Note that there may still be D-Bus traffic to process (relating to owning
     * and unowning the name) in the current thread-default {@link org.gtk.glib.MainContext} after
     * this function has returned. You should continue to iterate the {@link org.gtk.glib.MainContext}
     * until the {@link org.gtk.glib.DestroyNotify} function passed to g_bus_own_name() is called, in
     * order to avoid memory leaks through callbacks queued on the {@link org.gtk.glib.MainContext}
     * after its stopped being iterated.
     * @param ownerId an identifier obtained from g_bus_own_name()
     */
    public static void busUnownName(int ownerId) {
        try {
            DowncallHandles.g_bus_unown_name.invokeExact(
                    ownerId);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Stops watching a name.
     * <p>
     * Note that there may still be D-Bus traffic to process (relating to watching
     * and unwatching the name) in the current thread-default {@link org.gtk.glib.MainContext} after
     * this function has returned. You should continue to iterate the {@link org.gtk.glib.MainContext}
     * until the {@link org.gtk.glib.DestroyNotify} function passed to g_bus_watch_name() is called, in
     * order to avoid memory leaks through callbacks queued on the {@link org.gtk.glib.MainContext}
     * after its stopped being iterated.
     * @param watcherId An identifier obtained from g_bus_watch_name()
     */
    public static void busUnwatchName(int watcherId) {
        try {
            DowncallHandles.g_bus_unwatch_name.invokeExact(
                    watcherId);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Starts watching {@code name} on the bus specified by {@code bus_type} and calls
     * {@code name_appeared_handler} and {@code name_vanished_handler} when the name is
     * known to have an owner respectively known to lose its
     * owner. Callbacks will be invoked in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread you are calling this function from.
     * <p>
     * You are guaranteed that one of the handlers will be invoked after
     * calling this function. When you are done watching the name, just
     * call g_bus_unwatch_name() with the watcher id this function
     * returns.
     * <p>
     * If the name vanishes or appears (for example the application owning
     * the name could restart), the handlers are also invoked. If the
     * {@link DBusConnection} that is used for watching the name disconnects, then
     * {@code name_vanished_handler} is invoked since it is no longer
     * possible to access the name.
     * <p>
     * Another guarantee is that invocations of {@code name_appeared_handler}
     * and {@code name_vanished_handler} are guaranteed to alternate; that
     * is, if {@code name_appeared_handler} is invoked then you are
     * guaranteed that the next time one of the handlers is invoked, it
     * will be {@code name_vanished_handler}. The reverse is also true.
     * <p>
     * This behavior makes it very simple to write applications that want
     * to take action when a certain [name exists][gdbus-watching-names].
     * Basically, the application should create object proxies in
     * {@code name_appeared_handler} and destroy them again (if any) in
     * {@code name_vanished_handler}.
     * @param busType The type of bus to watch a name on.
     * @param name The name (well-known or unique) to watch.
     * @param flags Flags from the {@link BusNameWatcherFlags} enumeration.
     * @param nameAppearedHandler Handler to invoke when {@code name} is known to exist or {@code null}.
     * @param nameVanishedHandler Handler to invoke when {@code name} is known to not exist or {@code null}.
     * @return An identifier (never 0) that can be used with
     * g_bus_unwatch_name() to stop watching the name.
     */
    public static int busWatchName(@NotNull org.gtk.gio.BusType busType, @NotNull java.lang.String name, @NotNull org.gtk.gio.BusNameWatcherFlags flags, @Nullable org.gtk.gio.BusNameAppearedCallback nameAppearedHandler, @Nullable org.gtk.gio.BusNameVanishedCallback nameVanishedHandler) {
        java.util.Objects.requireNonNull(busType, "Parameter 'busType' must not be null");
        java.util.Objects.requireNonNull(name, "Parameter 'name' must not be null");
        java.util.Objects.requireNonNull(flags, "Parameter 'flags' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_bus_watch_name.invokeExact(
                    busType.getValue(),
                    Interop.allocateNativeString(name),
                    flags.getValue(),
                    (Addressable) (nameAppearedHandler == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbBusNameAppearedCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (nameVanishedHandler == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbBusNameVanishedCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (nameAppearedHandler == null ? MemoryAddress.NULL : Interop.registerCallback(nameAppearedHandler)),
                    Interop.cbDestroyNotifySymbol());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT;
    }
    
    /**
     * Like g_bus_watch_name() but takes a {@link DBusConnection} instead of a
     * {@link BusType}.
     * @param connection A {@link DBusConnection}.
     * @param name The name (well-known or unique) to watch.
     * @param flags Flags from the {@link BusNameWatcherFlags} enumeration.
     * @param nameAppearedHandler Handler to invoke when {@code name} is known to exist or {@code null}.
     * @param nameVanishedHandler Handler to invoke when {@code name} is known to not exist or {@code null}.
     * @return An identifier (never 0) that can be used with
     * g_bus_unwatch_name() to stop watching the name.
     */
    public static int busWatchNameOnConnection(@NotNull org.gtk.gio.DBusConnection connection, @NotNull java.lang.String name, @NotNull org.gtk.gio.BusNameWatcherFlags flags, @Nullable org.gtk.gio.BusNameAppearedCallback nameAppearedHandler, @Nullable org.gtk.gio.BusNameVanishedCallback nameVanishedHandler) {
        java.util.Objects.requireNonNull(connection, "Parameter 'connection' must not be null");
        java.util.Objects.requireNonNull(name, "Parameter 'name' must not be null");
        java.util.Objects.requireNonNull(flags, "Parameter 'flags' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_bus_watch_name_on_connection.invokeExact(
                    connection.handle(),
                    Interop.allocateNativeString(name),
                    flags.getValue(),
                    (Addressable) (nameAppearedHandler == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbBusNameAppearedCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (nameVanishedHandler == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbBusNameVanishedCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (nameAppearedHandler == null ? MemoryAddress.NULL : Interop.registerCallback(nameAppearedHandler)),
                    Interop.cbDestroyNotifySymbol());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT;
    }
    
    /**
     * Version of g_bus_watch_name_on_connection() using closures instead of callbacks for
     * easier binding in other languages.
     * @param connection A {@link DBusConnection}.
     * @param name The name (well-known or unique) to watch.
     * @param flags Flags from the {@link BusNameWatcherFlags} enumeration.
     * @param nameAppearedClosure {@link org.gtk.gobject.Closure} to invoke when {@code name} is known
     * to exist or {@code null}.
     * @param nameVanishedClosure {@link org.gtk.gobject.Closure} to invoke when {@code name} is known
     * to not exist or {@code null}.
     * @return An identifier (never 0) that can be used with
     * g_bus_unwatch_name() to stop watching the name.
     */
    public static int busWatchNameOnConnectionWithClosures(@NotNull org.gtk.gio.DBusConnection connection, @NotNull java.lang.String name, @NotNull org.gtk.gio.BusNameWatcherFlags flags, @Nullable org.gtk.gobject.Closure nameAppearedClosure, @Nullable org.gtk.gobject.Closure nameVanishedClosure) {
        java.util.Objects.requireNonNull(connection, "Parameter 'connection' must not be null");
        java.util.Objects.requireNonNull(name, "Parameter 'name' must not be null");
        java.util.Objects.requireNonNull(flags, "Parameter 'flags' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_bus_watch_name_on_connection_with_closures.invokeExact(
                    connection.handle(),
                    Interop.allocateNativeString(name),
                    flags.getValue(),
                    (Addressable) (nameAppearedClosure == null ? MemoryAddress.NULL : nameAppearedClosure.handle()),
                    (Addressable) (nameVanishedClosure == null ? MemoryAddress.NULL : nameVanishedClosure.handle()));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT;
    }
    
    /**
     * Version of g_bus_watch_name() using closures instead of callbacks for
     * easier binding in other languages.
     * @param busType The type of bus to watch a name on.
     * @param name The name (well-known or unique) to watch.
     * @param flags Flags from the {@link BusNameWatcherFlags} enumeration.
     * @param nameAppearedClosure {@link org.gtk.gobject.Closure} to invoke when {@code name} is known
     * to exist or {@code null}.
     * @param nameVanishedClosure {@link org.gtk.gobject.Closure} to invoke when {@code name} is known
     * to not exist or {@code null}.
     * @return An identifier (never 0) that can be used with
     * g_bus_unwatch_name() to stop watching the name.
     */
    public static int busWatchNameWithClosures(@NotNull org.gtk.gio.BusType busType, @NotNull java.lang.String name, @NotNull org.gtk.gio.BusNameWatcherFlags flags, @Nullable org.gtk.gobject.Closure nameAppearedClosure, @Nullable org.gtk.gobject.Closure nameVanishedClosure) {
        java.util.Objects.requireNonNull(busType, "Parameter 'busType' must not be null");
        java.util.Objects.requireNonNull(name, "Parameter 'name' must not be null");
        java.util.Objects.requireNonNull(flags, "Parameter 'flags' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_bus_watch_name_with_closures.invokeExact(
                    busType.getValue(),
                    Interop.allocateNativeString(name),
                    flags.getValue(),
                    (Addressable) (nameAppearedClosure == null ? MemoryAddress.NULL : nameAppearedClosure.handle()),
                    (Addressable) (nameVanishedClosure == null ? MemoryAddress.NULL : nameVanishedClosure.handle()));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT;
    }
    
    /**
     * Checks if a content type can be executable. Note that for instance
     * things like text files can be executables (i.e. scripts and batch files).
     * @param type a content type string
     * @return {@code true} if the file type corresponds to a type that
     *     can be executable, {@code false} otherwise.
     */
    public static boolean contentTypeCanBeExecutable(@NotNull java.lang.String type) {
        java.util.Objects.requireNonNull(type, "Parameter 'type' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_content_type_can_be_executable.invokeExact(
                    Interop.allocateNativeString(type));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Compares two content types for equality.
     * @param type1 a content type string
     * @param type2 a content type string
     * @return {@code true} if the two strings are identical or equivalent,
     *     {@code false} otherwise.
     */
    public static boolean contentTypeEquals(@NotNull java.lang.String type1, @NotNull java.lang.String type2) {
        java.util.Objects.requireNonNull(type1, "Parameter 'type1' must not be null");
        java.util.Objects.requireNonNull(type2, "Parameter 'type2' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_content_type_equals.invokeExact(
                    Interop.allocateNativeString(type1),
                    Interop.allocateNativeString(type2));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Tries to find a content type based on the mime type name.
     * @param mimeType a mime type string
     * @return Newly allocated string with content type or
     *     {@code null}. Free with g_free()
     */
    public static @Nullable java.lang.String contentTypeFromMimeType(@NotNull java.lang.String mimeType) {
        java.util.Objects.requireNonNull(mimeType, "Parameter 'mimeType' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_content_type_from_mime_type.invokeExact(
                    Interop.allocateNativeString(mimeType));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Gets the human readable description of the content type.
     * @param type a content type string
     * @return a short description of the content type {@code type}. Free the
     *     returned string with g_free()
     */
    public static @NotNull java.lang.String contentTypeGetDescription(@NotNull java.lang.String type) {
        java.util.Objects.requireNonNull(type, "Parameter 'type' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_content_type_get_description.invokeExact(
                    Interop.allocateNativeString(type));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Gets the generic icon name for a content type.
     * <p>
     * See the
     * <a href="http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec">shared-mime-info</a>
     * specification for more on the generic icon name.
     * @param type a content type string
     * @return the registered generic icon name for the given {@code type},
     *     or {@code null} if unknown. Free with g_free()
     */
    public static @Nullable java.lang.String contentTypeGetGenericIconName(@NotNull java.lang.String type) {
        java.util.Objects.requireNonNull(type, "Parameter 'type' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_content_type_get_generic_icon_name.invokeExact(
                    Interop.allocateNativeString(type));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Gets the icon for a content type.
     * @param type a content type string
     * @return {@link Icon} corresponding to the content type. Free the returned
     *     object with g_object_unref()
     */
    public static @NotNull org.gtk.gio.Icon contentTypeGetIcon(@NotNull java.lang.String type) {
        java.util.Objects.requireNonNull(type, "Parameter 'type' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_content_type_get_icon.invokeExact(
                    Interop.allocateNativeString(type));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.Icon.IconImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Get the list of directories which MIME data is loaded from. See
     * g_content_type_set_mime_dirs() for details.
     * @return {@code null}-terminated list of
     *    directories to load MIME data from, including any {@code mime/} subdirectory,
     *    and with the first directory to try listed first
     */
    public static @NotNull PointerString contentTypeGetMimeDirs() {
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_content_type_get_mime_dirs.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new PointerString(RESULT);
    }
    
    /**
     * Gets the mime type for the content type, if one is registered.
     * @param type a content type string
     * @return the registered mime type for the
     *     given {@code type}, or {@code null} if unknown; free with g_free().
     */
    public static @Nullable java.lang.String contentTypeGetMimeType(@NotNull java.lang.String type) {
        java.util.Objects.requireNonNull(type, "Parameter 'type' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_content_type_get_mime_type.invokeExact(
                    Interop.allocateNativeString(type));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Gets the symbolic icon for a content type.
     * @param type a content type string
     * @return symbolic {@link Icon} corresponding to the content type.
     *     Free the returned object with g_object_unref()
     */
    public static @NotNull org.gtk.gio.Icon contentTypeGetSymbolicIcon(@NotNull java.lang.String type) {
        java.util.Objects.requireNonNull(type, "Parameter 'type' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_content_type_get_symbolic_icon.invokeExact(
                    Interop.allocateNativeString(type));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.Icon.IconImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Guesses the content type based on example data. If the function is
     * uncertain, {@code result_uncertain} will be set to {@code true}. Either {@code filename}
     * or {@code data} may be {@code null}, in which case the guess will be based solely
     * on the other argument.
     * @param filename a path, or {@code null}
     * @param data a stream of data, or {@code null}
     * @param dataSize the size of {@code data}
     * @param resultUncertain return location for the certainty
     *     of the result, or {@code null}
     * @return a string indicating a guessed content type for the
     *     given data. Free with g_free()
     */
    public static @NotNull java.lang.String contentTypeGuess(@Nullable java.lang.String filename, @Nullable byte[] data, long dataSize, Out<Boolean> resultUncertain) {
        java.util.Objects.requireNonNull(resultUncertain, "Parameter 'resultUncertain' must not be null");
        MemorySegment resultUncertainPOINTER = Interop.getAllocator().allocate(Interop.valueLayout.C_INT);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_content_type_guess.invokeExact(
                    (Addressable) (filename == null ? MemoryAddress.NULL : Interop.allocateNativeString(filename)),
                    (Addressable) (data == null ? MemoryAddress.NULL : Interop.allocateNativeArray(data, false)),
                    dataSize,
                    (Addressable) resultUncertainPOINTER.address());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        resultUncertain.set(resultUncertainPOINTER.get(Interop.valueLayout.C_INT, 0) != 0);
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Tries to guess the type of the tree with root {@code root}, by
     * looking at the files it contains. The result is an array
     * of content types, with the best guess coming first.
     * <p>
     * The types returned all have the form x-content/foo, e.g.
     * x-content/audio-cdda (for audio CDs) or x-content/image-dcf
     * (for a camera memory card). See the
     * <a href="http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec">shared-mime-info</a>
     * specification for more on x-content types.
     * <p>
     * This function is useful in the implementation of
     * g_mount_guess_content_type().
     * @param root the root of the tree to guess a type for
     * @return an {@code null}-terminated
     *     array of zero or more content types. Free with g_strfreev()
     */
    public static @NotNull PointerString contentTypeGuessForTree(@NotNull org.gtk.gio.File root) {
        java.util.Objects.requireNonNull(root, "Parameter 'root' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_content_type_guess_for_tree.invokeExact(
                    root.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new PointerString(RESULT);
    }
    
    /**
     * Determines if {@code type} is a subset of {@code supertype}.
     * @param type a content type string
     * @param supertype a content type string
     * @return {@code true} if {@code type} is a kind of {@code supertype},
     *     {@code false} otherwise.
     */
    public static boolean contentTypeIsA(@NotNull java.lang.String type, @NotNull java.lang.String supertype) {
        java.util.Objects.requireNonNull(type, "Parameter 'type' must not be null");
        java.util.Objects.requireNonNull(supertype, "Parameter 'supertype' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_content_type_is_a.invokeExact(
                    Interop.allocateNativeString(type),
                    Interop.allocateNativeString(supertype));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Determines if {@code type} is a subset of {@code mime_type}.
     * Convenience wrapper around g_content_type_is_a().
     * @param type a content type string
     * @param mimeType a mime type string
     * @return {@code true} if {@code type} is a kind of {@code mime_type},
     *     {@code false} otherwise.
     */
    public static boolean contentTypeIsMimeType(@NotNull java.lang.String type, @NotNull java.lang.String mimeType) {
        java.util.Objects.requireNonNull(type, "Parameter 'type' must not be null");
        java.util.Objects.requireNonNull(mimeType, "Parameter 'mimeType' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_content_type_is_mime_type.invokeExact(
                    Interop.allocateNativeString(type),
                    Interop.allocateNativeString(mimeType));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Checks if the content type is the generic "unknown" type.
     * On UNIX this is the "application/octet-stream" mimetype,
     * while on win32 it is "*" and on OSX it is a dynamic type
     * or octet-stream.
     * @param type a content type string
     * @return {@code true} if the type is the unknown type.
     */
    public static boolean contentTypeIsUnknown(@NotNull java.lang.String type) {
        java.util.Objects.requireNonNull(type, "Parameter 'type' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_content_type_is_unknown.invokeExact(
                    Interop.allocateNativeString(type));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Set the list of directories used by GIO to load the MIME database.
     * If {@code dirs} is {@code null}, the directories used are the default:
     * <ul>
     * <li>the {@code mime} subdirectory of the directory in {@code $XDG_DATA_HOME}
     * <li>the {@code mime} subdirectory of every directory in {@code $XDG_DATA_DIRS}
     * </ul>
     * <p>
     * This function is intended to be used when writing tests that depend on
     * information stored in the MIME database, in order to control the data.
     * <p>
     * Typically, in case your tests use {@code G_TEST_OPTION_ISOLATE_DIRS}, but they
     * depend on the systems MIME database, you should call this function
     * with {@code dirs} set to {@code null} before calling g_test_init(), for instance:
     * <pre>{@code <!-- language="C" -->
     *   // Load MIME data from the system
     *   g_content_type_set_mime_dirs (NULL);
     *   // Isolate the environment
     *   g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
     * 
     *   
     * 
     *   return g_test_run ();
     * }</pre>
     * @param dirs {@code null}-terminated list of
     *    directories to load MIME data from, including any {@code mime/} subdirectory,
     *    and with the first directory to try listed first
     */
    public static void contentTypeSetMimeDirs(@Nullable java.lang.String[] dirs) {
        try {
            DowncallHandles.g_content_type_set_mime_dirs.invokeExact(
                    (Addressable) (dirs == null ? MemoryAddress.NULL : Interop.allocateNativeArray(dirs, false)));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Gets a list of strings containing all the registered content types
     * known to the system. The list and its data should be freed using
     * {@code g_list_free_full (list, g_free)}.
     * @return list of the registered
     *     content types
     */
    public static @NotNull org.gtk.glib.List contentTypesGetRegistered() {
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_content_types_get_registered.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.List(RESULT, Ownership.FULL);
    }
    
    /**
     * Escape {@code string} so it can appear in a D-Bus address as the value
     * part of a key-value pair.
     * <p>
     * For instance, if {@code string} is {@code /run/bus-for-:0},
     * this function would return {@code /run/bus-for-%3A0},
     * which could be used in a D-Bus address like
     * {@code unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-%3A0}.
     * @param string an unescaped string to be included in a D-Bus address
     *     as the value in a key-value pair
     * @return a copy of {@code string} with all
     *     non-optionally-escaped bytes escaped
     */
    public static @NotNull java.lang.String dbusAddressEscapeValue(@NotNull java.lang.String string) {
        java.util.Objects.requireNonNull(string, "Parameter 'string' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_dbus_address_escape_value.invokeExact(
                    Interop.allocateNativeString(string));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Synchronously looks up the D-Bus address for the well-known message
     * bus instance specified by {@code bus_type}. This may involve using various
     * platform specific mechanisms.
     * <p>
     * The returned address will be in the
     * <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#addresses">D-Bus address format</a>.
     * @param busType a {@link BusType}
     * @param cancellable a {@link Cancellable} or {@code null}
     * @return a valid D-Bus address string for {@code bus_type} or
     *     {@code null} if {@code error} is set
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull java.lang.String dbusAddressGetForBusSync(@NotNull org.gtk.gio.BusType busType, @Nullable org.gtk.gio.Cancellable cancellable) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(busType, "Parameter 'busType' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_dbus_address_get_for_bus_sync.invokeExact(
                    busType.getValue(),
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Asynchronously connects to an endpoint specified by {@code address} and
     * sets up the connection so it is in a state to run the client-side
     * of the D-Bus authentication conversation. {@code address} must be in the
     * <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#addresses">D-Bus address format</a>.
     * <p>
     * When the operation is finished, {@code callback} will be invoked. You can
     * then call g_dbus_address_get_stream_finish() to get the result of
     * the operation.
     * <p>
     * This is an asynchronous failable function. See
     * g_dbus_address_get_stream_sync() for the synchronous version.
     * @param address A valid D-Bus address.
     * @param cancellable A {@link Cancellable} or {@code null}.
     * @param callback A {@link AsyncReadyCallback} to call when the request is satisfied.
     */
    public static void dbusAddressGetStream(@NotNull java.lang.String address, @Nullable org.gtk.gio.Cancellable cancellable, @Nullable org.gtk.gio.AsyncReadyCallback callback) {
        java.util.Objects.requireNonNull(address, "Parameter 'address' must not be null");
        try {
            DowncallHandles.g_dbus_address_get_stream.invokeExact(
                    Interop.allocateNativeString(address),
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()),
                    (Addressable) (callback == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbAsyncReadyCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (callback == null ? MemoryAddress.NULL : Interop.registerCallback(callback)));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Finishes an operation started with g_dbus_address_get_stream().
     * <p>
     * A server is not required to set a GUID, so {@code out_guid} may be set to {@code null}
     * even on success.
     * @param res A {@link AsyncResult} obtained from the GAsyncReadyCallback passed to g_dbus_address_get_stream().
     * @param outGuid {@code null} or return location to store the GUID extracted from {@code address}, if any.
     * @return A {@link IOStream} or {@code null} if {@code error} is set.
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.IOStream dbusAddressGetStreamFinish(@NotNull org.gtk.gio.AsyncResult res, @Nullable Out<java.lang.String> outGuid) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(res, "Parameter 'res' must not be null");
        MemorySegment outGuidPOINTER = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_dbus_address_get_stream_finish.invokeExact(
                    res.handle(),
                    (Addressable) (outGuid == null ? MemoryAddress.NULL : (Addressable) outGuidPOINTER.address()),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        if (outGuid != null) outGuid.set(Interop.getStringFrom(outGuidPOINTER.get(Interop.valueLayout.ADDRESS, 0)));
        return new org.gtk.gio.IOStream(RESULT, Ownership.FULL);
    }
    
    /**
     * Synchronously connects to an endpoint specified by {@code address} and
     * sets up the connection so it is in a state to run the client-side
     * of the D-Bus authentication conversation. {@code address} must be in the
     * <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#addresses">D-Bus address format</a>.
     * <p>
     * A server is not required to set a GUID, so {@code out_guid} may be set to {@code null}
     * even on success.
     * <p>
     * This is a synchronous failable function. See
     * g_dbus_address_get_stream() for the asynchronous version.
     * @param address A valid D-Bus address.
     * @param outGuid {@code null} or return location to store the GUID extracted from {@code address}, if any.
     * @param cancellable A {@link Cancellable} or {@code null}.
     * @return A {@link IOStream} or {@code null} if {@code error} is set.
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.IOStream dbusAddressGetStreamSync(@NotNull java.lang.String address, @Nullable Out<java.lang.String> outGuid, @Nullable org.gtk.gio.Cancellable cancellable) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(address, "Parameter 'address' must not be null");
        MemorySegment outGuidPOINTER = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_dbus_address_get_stream_sync.invokeExact(
                    Interop.allocateNativeString(address),
                    (Addressable) (outGuid == null ? MemoryAddress.NULL : (Addressable) outGuidPOINTER.address()),
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        if (outGuid != null) outGuid.set(Interop.getStringFrom(outGuidPOINTER.get(Interop.valueLayout.ADDRESS, 0)));
        return new org.gtk.gio.IOStream(RESULT, Ownership.FULL);
    }
    
    /**
     * Looks up the value of an annotation.
     * <p>
     * The cost of this function is O(n) in number of annotations.
     * @param annotations A {@code null}-terminated array of annotations or {@code null}.
     * @param name The name of the annotation to look up.
     * @return The value or {@code null} if not found. Do not free, it is owned by {@code annotations}.
     */
    public static @Nullable java.lang.String dbusAnnotationInfoLookup(@Nullable org.gtk.gio.DBusAnnotationInfo[] annotations, @NotNull java.lang.String name) {
        java.util.Objects.requireNonNull(name, "Parameter 'name' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_dbus_annotation_info_lookup.invokeExact(
                    (Addressable) (annotations == null ? MemoryAddress.NULL : Interop.allocateNativeArray(annotations, false)),
                    Interop.allocateNativeString(name));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Creates a D-Bus error name to use for {@code error}. If {@code error} matches
     * a registered error (cf. g_dbus_error_register_error()), the corresponding
     * D-Bus error name will be returned.
     * <p>
     * Otherwise the a name of the form
     * {@code org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE}
     * will be used. This allows other GDBus applications to map the error
     * on the wire back to a {@link org.gtk.glib.Error} using g_dbus_error_new_for_dbus_error().
     * <p>
     * This function is typically only used in object mappings to put a
     * {@link org.gtk.glib.Error} on the wire. Regular applications should not use it.
     * @param error A {@link org.gtk.glib.Error}.
     * @return A D-Bus error name (never {@code null}).
     *     Free with g_free().
     */
    public static @NotNull java.lang.String dbusErrorEncodeGerror(@NotNull org.gtk.glib.Error error) {
        java.util.Objects.requireNonNull(error, "Parameter 'error' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_dbus_error_encode_gerror.invokeExact(
                    error.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Gets the D-Bus error name used for {@code error}, if any.
     * <p>
     * This function is guaranteed to return a D-Bus error name for all
     * {@code GErrors} returned from functions handling remote method calls
     * (e.g. g_dbus_connection_call_finish()) unless
     * g_dbus_error_strip_remote_error() has been used on {@code error}.
     * @param error a {@link org.gtk.glib.Error}
     * @return an allocated string or {@code null} if the
     *     D-Bus error name could not be found. Free with g_free().
     */
    public static @Nullable java.lang.String dbusErrorGetRemoteError(@NotNull org.gtk.glib.Error error) {
        java.util.Objects.requireNonNull(error, "Parameter 'error' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_dbus_error_get_remote_error.invokeExact(
                    error.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Checks if {@code error} represents an error received via D-Bus from a remote peer. If so,
     * use g_dbus_error_get_remote_error() to get the name of the error.
     * @param error A {@link org.gtk.glib.Error}.
     * @return {@code true} if {@code error} represents an error from a remote peer,
     * {@code false} otherwise.
     */
    public static boolean dbusErrorIsRemoteError(@NotNull org.gtk.glib.Error error) {
        java.util.Objects.requireNonNull(error, "Parameter 'error' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_dbus_error_is_remote_error.invokeExact(
                    error.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Creates a {@link org.gtk.glib.Error} based on the contents of {@code dbus_error_name} and
     * {@code dbus_error_message}.
     * <p>
     * Errors registered with g_dbus_error_register_error() will be looked
     * up using {@code dbus_error_name} and if a match is found, the error domain
     * and code is used. Applications can use g_dbus_error_get_remote_error()
     * to recover {@code dbus_error_name}.
     * <p>
     * If a match against a registered error is not found and the D-Bus
     * error name is in a form as returned by g_dbus_error_encode_gerror()
     * the error domain and code encoded in the name is used to
     * create the {@link org.gtk.glib.Error}. Also, {@code dbus_error_name} is added to the error message
     * such that it can be recovered with g_dbus_error_get_remote_error().
     * <p>
     * Otherwise, a {@link org.gtk.glib.Error} with the error code {@link IOErrorEnum#DBUS_ERROR}
     * in the {@code G_IO_ERROR} error domain is returned. Also, {@code dbus_error_name} is
     * added to the error message such that it can be recovered with
     * g_dbus_error_get_remote_error().
     * <p>
     * In all three cases, {@code dbus_error_name} can always be recovered from the
     * returned {@link org.gtk.glib.Error} using the g_dbus_error_get_remote_error() function
     * (unless g_dbus_error_strip_remote_error() hasn't been used on the returned error).
     * <p>
     * This function is typically only used in object mappings to prepare
     * {@link org.gtk.glib.Error} instances for applications. Regular applications should not use
     * it.
     * @param dbusErrorName D-Bus error name.
     * @param dbusErrorMessage D-Bus error message.
     * @return An allocated {@link org.gtk.glib.Error}. Free with g_error_free().
     */
    public static @NotNull org.gtk.glib.Error dbusErrorNewForDbusError(@NotNull java.lang.String dbusErrorName, @NotNull java.lang.String dbusErrorMessage) {
        java.util.Objects.requireNonNull(dbusErrorName, "Parameter 'dbusErrorName' must not be null");
        java.util.Objects.requireNonNull(dbusErrorMessage, "Parameter 'dbusErrorMessage' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_dbus_error_new_for_dbus_error.invokeExact(
                    Interop.allocateNativeString(dbusErrorName),
                    Interop.allocateNativeString(dbusErrorMessage));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.Error(RESULT, Ownership.FULL);
    }
    
    public static @NotNull org.gtk.glib.Quark dbusErrorQuark() {
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_dbus_error_quark.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.Quark(RESULT);
    }
    
    /**
     * Creates an association to map between {@code dbus_error_name} and
     * {@code GErrors} specified by {@code error_domain} and {@code error_code}.
     * <p>
     * This is typically done in the routine that returns the {@link org.gtk.glib.Quark} for
     * an error domain.
     * @param errorDomain A {@link org.gtk.glib.Quark} for an error domain.
     * @param errorCode An error code.
     * @param dbusErrorName A D-Bus error name.
     * @return {@code true} if the association was created, {@code false} if it already
     * exists.
     */
    public static boolean dbusErrorRegisterError(@NotNull org.gtk.glib.Quark errorDomain, int errorCode, @NotNull java.lang.String dbusErrorName) {
        java.util.Objects.requireNonNull(errorDomain, "Parameter 'errorDomain' must not be null");
        java.util.Objects.requireNonNull(dbusErrorName, "Parameter 'dbusErrorName' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_dbus_error_register_error.invokeExact(
                    errorDomain.getValue().intValue(),
                    errorCode,
                    Interop.allocateNativeString(dbusErrorName));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Helper function for associating a {@link org.gtk.glib.Error} error domain with D-Bus error names.
     * <p>
     * While {@code quark_volatile} has a {@code volatile} qualifier, this is a historical
     * artifact and the argument passed to it should not be {@code volatile}.
     * @param errorDomainQuarkName The error domain name.
     * @param quarkVolatile A pointer where to store the {@link org.gtk.glib.Quark}.
     * @param entries A pointer to {@code num_entries} {@link DBusErrorEntry} struct items.
     * @param numEntries Number of items to register.
     */
    public static void dbusErrorRegisterErrorDomain(@NotNull java.lang.String errorDomainQuarkName, PointerLong quarkVolatile, @NotNull org.gtk.gio.DBusErrorEntry[] entries, int numEntries) {
        java.util.Objects.requireNonNull(errorDomainQuarkName, "Parameter 'errorDomainQuarkName' must not be null");
        java.util.Objects.requireNonNull(quarkVolatile, "Parameter 'quarkVolatile' must not be null");
        java.util.Objects.requireNonNull(entries, "Parameter 'entries' must not be null");
        try {
            DowncallHandles.g_dbus_error_register_error_domain.invokeExact(
                    Interop.allocateNativeString(errorDomainQuarkName),
                    quarkVolatile.handle(),
                    Interop.allocateNativeArray(entries, org.gtk.gio.DBusErrorEntry.getMemoryLayout(), false),
                    numEntries);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Looks for extra information in the error message used to recover
     * the D-Bus error name and strips it if found. If stripped, the
     * message field in {@code error} will correspond exactly to what was
     * received on the wire.
     * <p>
     * This is typically used when presenting errors to the end user.
     * @param error A {@link org.gtk.glib.Error}.
     * @return {@code true} if information was stripped, {@code false} otherwise.
     */
    public static boolean dbusErrorStripRemoteError(@NotNull org.gtk.glib.Error error) {
        java.util.Objects.requireNonNull(error, "Parameter 'error' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_dbus_error_strip_remote_error.invokeExact(
                    error.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Destroys an association previously set up with g_dbus_error_register_error().
     * @param errorDomain A {@link org.gtk.glib.Quark} for an error domain.
     * @param errorCode An error code.
     * @param dbusErrorName A D-Bus error name.
     * @return {@code true} if the association was destroyed, {@code false} if it wasn't found.
     */
    public static boolean dbusErrorUnregisterError(@NotNull org.gtk.glib.Quark errorDomain, int errorCode, @NotNull java.lang.String dbusErrorName) {
        java.util.Objects.requireNonNull(errorDomain, "Parameter 'errorDomain' must not be null");
        java.util.Objects.requireNonNull(dbusErrorName, "Parameter 'dbusErrorName' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_dbus_error_unregister_error.invokeExact(
                    errorDomain.getValue().intValue(),
                    errorCode,
                    Interop.allocateNativeString(dbusErrorName));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * This is a language binding friendly version of g_dbus_escape_object_path_bytestring().
     * @param s the string to escape
     * @return an escaped version of {@code s}. Free with g_free().
     */
    public static @NotNull java.lang.String dbusEscapeObjectPath(@NotNull java.lang.String s) {
        java.util.Objects.requireNonNull(s, "Parameter 's' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_dbus_escape_object_path.invokeExact(
                    Interop.allocateNativeString(s));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Escapes {@code bytes} for use in a D-Bus object path component.
     * {@code bytes} is an array of zero or more nonzero bytes in an
     * unspecified encoding, followed by a single zero byte.
     * <p>
     * The escaping method consists of replacing all non-alphanumeric
     * characters (see g_ascii_isalnum()) with their hexadecimal value
     * preceded by an underscore ({@code _}). For example:
     * {@code foo.bar.baz} will become {@code foo_2ebar_2ebaz}.
     * <p>
     * This method is appropriate to use when the input is nearly
     * a valid object path component but is not when your input
     * is far from being a valid object path component.
     * Other escaping algorithms are also valid to use with
     * D-Bus object paths.
     * <p>
     * This can be reversed with g_dbus_unescape_object_path().
     * @param bytes the string of bytes to escape
     * @return an escaped version of {@code bytes}. Free with g_free().
     */
    public static @NotNull java.lang.String dbusEscapeObjectPathBytestring(@NotNull byte[] bytes) {
        java.util.Objects.requireNonNull(bytes, "Parameter 'bytes' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_dbus_escape_object_path_bytestring.invokeExact(
                    Interop.allocateNativeArray(bytes, false));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Generate a D-Bus GUID that can be used with
     * e.g. g_dbus_connection_new().
     * <p>
     * See the
     * <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#uuids">D-Bus specification</a>
     * regarding what strings are valid D-Bus GUIDs. The specification refers to
     * these as UUIDs whereas GLib (for historical reasons) refers to them as
     * GUIDs. The terms are interchangeable.
     * <p>
     * Note that D-Bus GUIDs do not follow
     * <a href="https://datatracker.ietf.org/doc/html/rfc4122">RFC 4122</a>.
     * @return A valid D-Bus GUID. Free with g_free().
     */
    public static @NotNull java.lang.String dbusGenerateGuid() {
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_dbus_generate_guid.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Converts a {@link org.gtk.gobject.Value} to a {@link org.gtk.glib.Variant} of the type indicated by the {@code type}
     * parameter.
     * <p>
     * The conversion is using the following rules:
     * <ul>
     * <li>{@code G_TYPE_STRING}: 's', 'o', 'g' or 'ay'
     * <li>{@code G_TYPE_STRV}: 'as', 'ao' or 'aay'
     * <li>{@code G_TYPE_BOOLEAN}: 'b'
     * <li>{@code G_TYPE_UCHAR}: 'y'
     * <li>{@code G_TYPE_INT}: 'i', 'n'
     * <li>{@code G_TYPE_UINT}: 'u', 'q'
     * <li>{@code G_TYPE_INT64}: 'x'
     * <li>{@code G_TYPE_UINT64}: 't'
     * <li>{@code G_TYPE_DOUBLE}: 'd'
     * <li>{@code G_TYPE_VARIANT}: Any {@link org.gtk.glib.VariantType}
     * </ul>
     * <p>
     * This can fail if e.g. {@code gvalue} is of type {@code G_TYPE_STRING} and {@code type}
     * is 'i', i.e. {@code G_VARIANT_TYPE_INT32}. It will also fail for any {@link org.gtk.gobject.Type}
     * (including e.g. {@code G_TYPE_OBJECT} and {@code G_TYPE_BOXED} derived-types) not
     * in the table above.
     * <p>
     * Note that if {@code gvalue} is of type {@code G_TYPE_VARIANT} and its value is
     * {@code null}, the empty {@link org.gtk.glib.Variant} instance (never {@code null}) for {@code type} is
     * returned (e.g. 0 for scalar types, the empty string for string types,
     * '/' for object path types, the empty array for any array type and so on).
     * <p>
     * See the g_dbus_gvariant_to_gvalue() function for how to convert a
     * {@link org.gtk.glib.Variant} to a {@link org.gtk.gobject.Value}.
     * @param gvalue A {@link org.gtk.gobject.Value} to convert to a {@link org.gtk.glib.Variant}
     * @param type A {@link org.gtk.glib.VariantType}
     * @return A {@link org.gtk.glib.Variant} (never floating) of
     *     {@link org.gtk.glib.VariantType} {@code type} holding the data from {@code gvalue} or an empty {@link org.gtk.glib.Variant}
     *     in case of failure. Free with g_variant_unref().
     */
    public static @NotNull org.gtk.glib.Variant dbusGvalueToGvariant(@NotNull org.gtk.gobject.Value gvalue, @NotNull org.gtk.glib.VariantType type) {
        java.util.Objects.requireNonNull(gvalue, "Parameter 'gvalue' must not be null");
        java.util.Objects.requireNonNull(type, "Parameter 'type' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_dbus_gvalue_to_gvariant.invokeExact(
                    gvalue.handle(),
                    type.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.Variant(RESULT, Ownership.FULL);
    }
    
    /**
     * Converts a {@link org.gtk.glib.Variant} to a {@link org.gtk.gobject.Value}. If {@code value} is floating, it is consumed.
     * <p>
     * The rules specified in the g_dbus_gvalue_to_gvariant() function are
     * used - this function is essentially its reverse form. So, a {@link org.gtk.glib.Variant}
     * containing any basic or string array type will be converted to a {@link org.gtk.gobject.Value}
     * containing a basic value or string array. Any other {@link org.gtk.glib.Variant} (handle,
     * variant, tuple, dict entry) will be converted to a {@link org.gtk.gobject.Value} containing that
     * {@link org.gtk.glib.Variant}.
     * <p>
     * The conversion never fails - a valid {@link org.gtk.gobject.Value} is always returned in
     * {@code out_gvalue}.
     * @param value A {@link org.gtk.glib.Variant}.
     * @param outGvalue Return location pointing to a zero-filled (uninitialized) {@link org.gtk.gobject.Value}.
     */
    public static void dbusGvariantToGvalue(@NotNull org.gtk.glib.Variant value, @NotNull org.gtk.gobject.Value outGvalue) {
        java.util.Objects.requireNonNull(value, "Parameter 'value' must not be null");
        java.util.Objects.requireNonNull(outGvalue, "Parameter 'outGvalue' must not be null");
        try {
            DowncallHandles.g_dbus_gvariant_to_gvalue.invokeExact(
                    value.handle(),
                    outGvalue.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Checks if {@code string} is a
     * <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#addresses">D-Bus address</a>.
     * <p>
     * This doesn't check if {@code string} is actually supported by {@link DBusServer}
     * or {@link DBusConnection} - use g_dbus_is_supported_address() to do more
     * checks.
     * @param string A string.
     * @return {@code true} if {@code string} is a valid D-Bus address, {@code false} otherwise.
     */
    public static boolean dbusIsAddress(@NotNull java.lang.String string) {
        java.util.Objects.requireNonNull(string, "Parameter 'string' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_dbus_is_address.invokeExact(
                    Interop.allocateNativeString(string));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Check whether {@code string} is a valid D-Bus error name.
     * <p>
     * This function returns the same result as g_dbus_is_interface_name(),
     * because D-Bus error names are defined to have exactly the
     * same syntax as interface names.
     * @param string The string to check.
     * @return {@code true} if valid, {@code false} otherwise.
     */
    public static boolean dbusIsErrorName(@NotNull java.lang.String string) {
        java.util.Objects.requireNonNull(string, "Parameter 'string' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_dbus_is_error_name.invokeExact(
                    Interop.allocateNativeString(string));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Checks if {@code string} is a D-Bus GUID.
     * <p>
     * See the documentation for g_dbus_generate_guid() for more information about
     * the format of a GUID.
     * @param string The string to check.
     * @return {@code true} if {@code string} is a GUID, {@code false} otherwise.
     */
    public static boolean dbusIsGuid(@NotNull java.lang.String string) {
        java.util.Objects.requireNonNull(string, "Parameter 'string' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_dbus_is_guid.invokeExact(
                    Interop.allocateNativeString(string));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Checks if {@code string} is a valid D-Bus interface name.
     * @param string The string to check.
     * @return {@code true} if valid, {@code false} otherwise.
     */
    public static boolean dbusIsInterfaceName(@NotNull java.lang.String string) {
        java.util.Objects.requireNonNull(string, "Parameter 'string' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_dbus_is_interface_name.invokeExact(
                    Interop.allocateNativeString(string));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Checks if {@code string} is a valid D-Bus member (e.g. signal or method) name.
     * @param string The string to check.
     * @return {@code true} if valid, {@code false} otherwise.
     */
    public static boolean dbusIsMemberName(@NotNull java.lang.String string) {
        java.util.Objects.requireNonNull(string, "Parameter 'string' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_dbus_is_member_name.invokeExact(
                    Interop.allocateNativeString(string));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Checks if {@code string} is a valid D-Bus bus name (either unique or well-known).
     * @param string The string to check.
     * @return {@code true} if valid, {@code false} otherwise.
     */
    public static boolean dbusIsName(@NotNull java.lang.String string) {
        java.util.Objects.requireNonNull(string, "Parameter 'string' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_dbus_is_name.invokeExact(
                    Interop.allocateNativeString(string));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Like g_dbus_is_address() but also checks if the library supports the
     * transports in {@code string} and that key/value pairs for each transport
     * are valid. See the specification of the
     * <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#addresses">D-Bus address format</a>.
     * @param string A string.
     * @return {@code true} if {@code string} is a valid D-Bus address that is
     * supported by this library, {@code false} if {@code error} is set.
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static boolean dbusIsSupportedAddress(@NotNull java.lang.String string) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(string, "Parameter 'string' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_dbus_is_supported_address.invokeExact(
                    Interop.allocateNativeString(string),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return RESULT != 0;
    }
    
    /**
     * Checks if {@code string} is a valid D-Bus unique bus name.
     * @param string The string to check.
     * @return {@code true} if valid, {@code false} otherwise.
     */
    public static boolean dbusIsUniqueName(@NotNull java.lang.String string) {
        java.util.Objects.requireNonNull(string, "Parameter 'string' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_dbus_is_unique_name.invokeExact(
                    Interop.allocateNativeString(string));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Unescapes an string that was previously escaped with
     * g_dbus_escape_object_path(). If the string is in a format that could
     * not have been returned by g_dbus_escape_object_path(), this function
     * returns {@code null}.
     * <p>
     * Encoding alphanumeric characters which do not need to be
     * encoded is not allowed (e.g {@code _63} is not valid, the string
     * should contain {@code c} instead).
     * @param s the string to unescape
     * @return an
     *   unescaped version of {@code s}, or {@code null} if {@code s} is not a string returned
     *   from g_dbus_escape_object_path(). Free with g_free().
     */
    public static @Nullable PointerByte dbusUnescapeObjectPath(@NotNull java.lang.String s) {
        java.util.Objects.requireNonNull(s, "Parameter 's' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_dbus_unescape_object_path.invokeExact(
                    Interop.allocateNativeString(s));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new PointerByte(RESULT);
    }
    
    /**
     * Creates a new {@link DtlsClientConnection} wrapping {@code base_socket} which is
     * assumed to communicate with the server identified by {@code server_identity}.
     * @param baseSocket the {@link DatagramBased} to wrap
     * @param serverIdentity the expected identity of the server
     * @return the new
     *   {@link DtlsClientConnection}, or {@code null} on error
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.DtlsClientConnection dtlsClientConnectionNew(@NotNull org.gtk.gio.DatagramBased baseSocket, @Nullable org.gtk.gio.SocketConnectable serverIdentity) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(baseSocket, "Parameter 'baseSocket' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_dtls_client_connection_new.invokeExact(
                    baseSocket.handle(),
                    (Addressable) (serverIdentity == null ? MemoryAddress.NULL : serverIdentity.handle()),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.DtlsClientConnection.DtlsClientConnectionImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Creates a new {@link DtlsServerConnection} wrapping {@code base_socket}.
     * @param baseSocket the {@link DatagramBased} to wrap
     * @param certificate the default server certificate, or {@code null}
     * @return the new
     *   {@link DtlsServerConnection}, or {@code null} on error
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.DtlsServerConnection dtlsServerConnectionNew(@NotNull org.gtk.gio.DatagramBased baseSocket, @Nullable org.gtk.gio.TlsCertificate certificate) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(baseSocket, "Parameter 'baseSocket' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_dtls_server_connection_new.invokeExact(
                    baseSocket.handle(),
                    (Addressable) (certificate == null ? MemoryAddress.NULL : certificate.handle()),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.DtlsServerConnection.DtlsServerConnectionImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Creates a {@link File} with the given argument from the command line.
     * The value of {@code arg} can be either a URI, an absolute path or a
     * relative path resolved relative to the current working directory.
     * This operation never fails, but the returned object might not
     * support any I/O operation if {@code arg} points to a malformed path.
     * <p>
     * Note that on Windows, this function expects its argument to be in
     * UTF-8 -- not the system code page.  This means that you
     * should not use this function with string from argv as it is passed
     * to main().  g_win32_get_command_line() will return a UTF-8 version of
     * the commandline.  {@link Application} also uses UTF-8 but
     * g_application_command_line_create_file_for_arg() may be more useful
     * for you there.  It is also always possible to use this function with
     * {@link org.gtk.glib.OptionContext} arguments of type {@link org.gtk.glib.OptionArg#FILENAME}.
     * @param arg a command line string
     * @return a new {@link File}.
     *   Free the returned object with g_object_unref().
     */
    public static @NotNull org.gtk.gio.File fileNewForCommandlineArg(@NotNull java.lang.String arg) {
        java.util.Objects.requireNonNull(arg, "Parameter 'arg' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_file_new_for_commandline_arg.invokeExact(
                    Interop.allocateNativeString(arg));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.File.FileImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Creates a {@link File} with the given argument from the command line.
     * <p>
     * This function is similar to g_file_new_for_commandline_arg() except
     * that it allows for passing the current working directory as an
     * argument instead of using the current working directory of the
     * process.
     * <p>
     * This is useful if the commandline argument was given in a context
     * other than the invocation of the current process.
     * <p>
     * See also g_application_command_line_create_file_for_arg().
     * @param arg a command line string
     * @param cwd the current working directory of the commandline
     * @return a new {@link File}
     */
    public static @NotNull org.gtk.gio.File fileNewForCommandlineArgAndCwd(@NotNull java.lang.String arg, @NotNull java.lang.String cwd) {
        java.util.Objects.requireNonNull(arg, "Parameter 'arg' must not be null");
        java.util.Objects.requireNonNull(cwd, "Parameter 'cwd' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_file_new_for_commandline_arg_and_cwd.invokeExact(
                    Interop.allocateNativeString(arg),
                    Interop.allocateNativeString(cwd));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.File.FileImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Constructs a {@link File} for a given path. This operation never
     * fails, but the returned object might not support any I/O
     * operation if {@code path} is malformed.
     * @param path a string containing a relative or absolute path.
     *   The string must be encoded in the glib filename encoding.
     * @return a new {@link File} for the given {@code path}.
     *   Free the returned object with g_object_unref().
     */
    public static @NotNull org.gtk.gio.File fileNewForPath(@NotNull java.lang.String path) {
        java.util.Objects.requireNonNull(path, "Parameter 'path' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_file_new_for_path.invokeExact(
                    Interop.allocateNativeString(path));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.File.FileImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Constructs a {@link File} for a given URI. This operation never
     * fails, but the returned object might not support any I/O
     * operation if {@code uri} is malformed or if the uri type is
     * not supported.
     * @param uri a UTF-8 string containing a URI
     * @return a new {@link File} for the given {@code uri}.
     *   Free the returned object with g_object_unref().
     */
    public static @NotNull org.gtk.gio.File fileNewForUri(@NotNull java.lang.String uri) {
        java.util.Objects.requireNonNull(uri, "Parameter 'uri' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_file_new_for_uri.invokeExact(
                    Interop.allocateNativeString(uri));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.File.FileImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Opens a file in the preferred directory for temporary files (as
     * returned by g_get_tmp_dir()) and returns a {@link File} and
     * {@link FileIOStream} pointing to it.
     * <p>
     * {@code tmpl} should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is {@code null}, a default template is used.
     * <p>
     * Unlike the other {@link File} constructors, this will return {@code null} if
     * a temporary file could not be created.
     * @param tmpl Template for the file
     *   name, as in g_file_open_tmp(), or {@code null} for a default template
     * @param iostream on return, a {@link FileIOStream} for the created file
     * @return a new {@link File}.
     *   Free the returned object with g_object_unref().
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.File fileNewTmp(@Nullable java.lang.String tmpl, @NotNull PointerProxy<org.gtk.gio.FileIOStream> iostream) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(iostream, "Parameter 'iostream' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_file_new_tmp.invokeExact(
                    (Addressable) (tmpl == null ? MemoryAddress.NULL : Interop.allocateNativeString(tmpl)),
                    iostream.handle(),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.File.FileImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Asynchronously opens a file in the preferred directory for temporary files
     *  (as returned by g_get_tmp_dir()) as g_file_new_tmp().
     * <p>
     * {@code tmpl} should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is {@code null}, a default template is used.
     * @param tmpl Template for the file
     *   name, as in g_file_open_tmp(), or {@code null} for a default template
     * @param ioPriority the [I/O priority][io-priority] of the request
     * @param cancellable optional {@link Cancellable} object, {@code null} to ignore
     * @param callback a {@link AsyncReadyCallback} to call when the request is done
     */
    public static void fileNewTmpAsync(@Nullable java.lang.String tmpl, int ioPriority, @Nullable org.gtk.gio.Cancellable cancellable, @Nullable org.gtk.gio.AsyncReadyCallback callback) {
        try {
            DowncallHandles.g_file_new_tmp_async.invokeExact(
                    (Addressable) (tmpl == null ? MemoryAddress.NULL : Interop.allocateNativeString(tmpl)),
                    ioPriority,
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()),
                    (Addressable) (callback == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbAsyncReadyCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (callback == null ? MemoryAddress.NULL : Interop.registerCallback(callback)));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Asynchronously creates a directory in the preferred directory for
     * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
     * <p>
     * {@code tmpl} should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is {@code null}, a default template is used.
     * @param tmpl Template for the file
     *   name, as in g_dir_make_tmp(), or {@code null} for a default template
     * @param ioPriority the [I/O priority][io-priority] of the request
     * @param cancellable optional {@link Cancellable} object, {@code null} to ignore
     * @param callback a {@link AsyncReadyCallback} to call when the request is done
     */
    public static void fileNewTmpDirAsync(@Nullable java.lang.String tmpl, int ioPriority, @Nullable org.gtk.gio.Cancellable cancellable, @Nullable org.gtk.gio.AsyncReadyCallback callback) {
        try {
            DowncallHandles.g_file_new_tmp_dir_async.invokeExact(
                    (Addressable) (tmpl == null ? MemoryAddress.NULL : Interop.allocateNativeString(tmpl)),
                    ioPriority,
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()),
                    (Addressable) (callback == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbAsyncReadyCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (callback == null ? MemoryAddress.NULL : Interop.registerCallback(callback)));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Finishes a temporary directory creation started by
     * g_file_new_tmp_dir_async().
     * @param result a {@link AsyncResult}
     * @return a new {@link File}.
     *   Free the returned object with g_object_unref().
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.File fileNewTmpDirFinish(@NotNull org.gtk.gio.AsyncResult result) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(result, "Parameter 'result' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_file_new_tmp_dir_finish.invokeExact(
                    result.handle(),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.File.FileImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Finishes a temporary file creation started by g_file_new_tmp_async().
     * @param result a {@link AsyncResult}
     * @param iostream on return, a {@link FileIOStream} for the created file
     * @return a new {@link File}.
     *   Free the returned object with g_object_unref().
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.File fileNewTmpFinish(@NotNull org.gtk.gio.AsyncResult result, @NotNull PointerProxy<org.gtk.gio.FileIOStream> iostream) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(result, "Parameter 'result' must not be null");
        java.util.Objects.requireNonNull(iostream, "Parameter 'iostream' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_file_new_tmp_finish.invokeExact(
                    result.handle(),
                    iostream.handle(),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.File.FileImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Constructs a {@link File} with the given {@code parse_name} (i.e. something
     * given by g_file_get_parse_name()). This operation never fails,
     * but the returned object might not support any I/O operation if
     * the {@code parse_name} cannot be parsed.
     * @param parseName a file name or path to be parsed
     * @return a new {@link File}.
     */
    public static @NotNull org.gtk.gio.File fileParseName(@NotNull java.lang.String parseName) {
        java.util.Objects.requireNonNull(parseName, "Parameter 'parseName' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_file_parse_name.invokeExact(
                    Interop.allocateNativeString(parseName));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.File.FileImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Deserializes a {@link Icon} previously serialized using g_icon_serialize().
     * @param value a {@link org.gtk.glib.Variant} created with g_icon_serialize()
     * @return a {@link Icon}, or {@code null} when deserialization fails.
     */
    public static @Nullable org.gtk.gio.Icon iconDeserialize(@NotNull org.gtk.glib.Variant value) {
        java.util.Objects.requireNonNull(value, "Parameter 'value' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_icon_deserialize.invokeExact(
                    value.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.Icon.IconImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Gets a hash for an icon.
     * @param icon {@code gconstpointer} to an icon object.
     * @return a {@code guint} containing a hash for the {@code icon}, suitable for
     * use in a {@link org.gtk.glib.HashTable} or similar data structure.
     */
    public static int iconHash(@NotNull java.lang.foreign.MemoryAddress icon) {
        java.util.Objects.requireNonNull(icon, "Parameter 'icon' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_icon_hash.invokeExact(
                    (Addressable) icon);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT;
    }
    
    /**
     * Generate a {@link Icon} instance from {@code str}. This function can fail if
     * {@code str} is not valid - see g_icon_to_string() for discussion.
     * <p>
     * If your application or library provides one or more {@link Icon}
     * implementations you need to ensure that each {@link org.gtk.gobject.Type} is registered
     * with the type system prior to calling g_icon_new_for_string().
     * @param str A string obtained via g_icon_to_string().
     * @return An object implementing the {@link Icon}
     *          interface or {@code null} if {@code error} is set.
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.Icon iconNewForString(@NotNull java.lang.String str) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(str, "Parameter 'str' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_icon_new_for_string.invokeExact(
                    Interop.allocateNativeString(str),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.Icon.IconImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Helper function for constructing {@link Initable} object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns {@code null}, setting an error on failure.
     * @param objectType a {@link org.gtk.gobject.Type} supporting {@link Initable}.
     * @param nParameters the number of parameters in {@code parameters}
     * @param parameters the parameters to use to construct the object
     * @param cancellable optional {@link Cancellable} object, {@code null} to ignore.
     * @return a newly allocated
     *      {@link org.gtk.gobject.Object}, or {@code null} on error
     * @throws GErrorException See {@link org.gtk.glib.Error}
     * @deprecated Use g_object_new_with_properties() and
     * g_initable_init() instead. See {@link org.gtk.gobject.Parameter} for more information.
     */
    @Deprecated
    public static @NotNull org.gtk.gobject.Object initableNewv(@NotNull org.gtk.glib.Type objectType, int nParameters, @NotNull org.gtk.gobject.Parameter[] parameters, @Nullable org.gtk.gio.Cancellable cancellable) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(objectType, "Parameter 'objectType' must not be null");
        java.util.Objects.requireNonNull(parameters, "Parameter 'parameters' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_initable_newv.invokeExact(
                    objectType.getValue().longValue(),
                    nParameters,
                    Interop.allocateNativeArray(parameters, org.gtk.gobject.Parameter.getMemoryLayout(), false),
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gobject.Object(RESULT, Ownership.FULL);
    }
    
    /**
     * Converts errno.h error codes into GIO error codes. The fallback
     * value {@link IOErrorEnum#FAILED} is returned for error codes not currently
     * handled (but note that future GLib releases may return a more
     * specific value instead).
     * <p>
     * As {@code errno} is global and may be modified by intermediate function
     * calls, you should save its value as soon as the call which sets it
     * @param errNo Error number as defined in errno.h.
     * @return {@link IOErrorEnum} value for the given errno.h error number.
     */
    public static @NotNull org.gtk.gio.IOErrorEnum ioErrorFromErrno(int errNo) {
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_io_error_from_errno.invokeExact(
                    errNo);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.IOErrorEnum(RESULT);
    }
    
    /**
     * Converts {@link org.gtk.glib.FileError} error codes into GIO error codes.
     * @param fileError a {@link org.gtk.glib.FileError}.
     * @return {@link IOErrorEnum} value for the given {@link org.gtk.glib.FileError} error value.
     */
    public static @NotNull org.gtk.gio.IOErrorEnum ioErrorFromFileError(@NotNull org.gtk.glib.FileError fileError) {
        java.util.Objects.requireNonNull(fileError, "Parameter 'fileError' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_io_error_from_file_error.invokeExact(
                    fileError.getValue());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.IOErrorEnum(RESULT);
    }
    
    /**
     * Gets the GIO Error Quark.
     * @return a {@link org.gtk.glib.Quark}.
     */
    public static @NotNull org.gtk.glib.Quark ioErrorQuark() {
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_io_error_quark.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.Quark(RESULT);
    }
    
    /**
     * Registers {@code type} as extension for the extension point with name
     * {@code extension_point_name}.
     * <p>
     * If {@code type} has already been registered as an extension for this
     * extension point, the existing {@link IOExtension} object is returned.
     * @param extensionPointName the name of the extension point
     * @param type the {@link org.gtk.gobject.Type} to register as extension
     * @param extensionName the name for the extension
     * @param priority the priority for the extension
     * @return a {@link IOExtension} object for {@link org.gtk.gobject.Type}
     */
    public static @NotNull org.gtk.gio.IOExtension ioExtensionPointImplement(@NotNull java.lang.String extensionPointName, @NotNull org.gtk.glib.Type type, @NotNull java.lang.String extensionName, int priority) {
        java.util.Objects.requireNonNull(extensionPointName, "Parameter 'extensionPointName' must not be null");
        java.util.Objects.requireNonNull(type, "Parameter 'type' must not be null");
        java.util.Objects.requireNonNull(extensionName, "Parameter 'extensionName' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_io_extension_point_implement.invokeExact(
                    Interop.allocateNativeString(extensionPointName),
                    type.getValue().longValue(),
                    Interop.allocateNativeString(extensionName),
                    priority);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.IOExtension(RESULT, Ownership.NONE);
    }
    
    /**
     * Looks up an existing extension point.
     * @param name the name of the extension point
     * @return the {@link IOExtensionPoint}, or {@code null} if there
     *    is no registered extension point with the given name.
     */
    public static @NotNull org.gtk.gio.IOExtensionPoint ioExtensionPointLookup(@NotNull java.lang.String name) {
        java.util.Objects.requireNonNull(name, "Parameter 'name' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_io_extension_point_lookup.invokeExact(
                    Interop.allocateNativeString(name));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.IOExtensionPoint(RESULT, Ownership.NONE);
    }
    
    /**
     * Registers an extension point.
     * @param name The name of the extension point
     * @return the new {@link IOExtensionPoint}. This object is
     *    owned by GIO and should not be freed.
     */
    public static @NotNull org.gtk.gio.IOExtensionPoint ioExtensionPointRegister(@NotNull java.lang.String name) {
        java.util.Objects.requireNonNull(name, "Parameter 'name' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_io_extension_point_register.invokeExact(
                    Interop.allocateNativeString(name));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.IOExtensionPoint(RESULT, Ownership.NONE);
    }
    
    /**
     * Loads all the modules in the specified directory.
     * <p>
     * If don't require all modules to be initialized (and thus registering
     * all gtypes) then you can use g_io_modules_scan_all_in_directory()
     * which allows delayed/lazy loading of modules.
     * @param dirname pathname for a directory containing modules
     *     to load.
     * @return a list of {@code GIOModules} loaded
     *      from the directory,
     *      All the modules are loaded into memory, if you want to
     *      unload them (enabling on-demand loading) you must call
     *      g_type_module_unuse() on all the modules. Free the list
     *      with g_list_free().
     */
    public static @NotNull org.gtk.glib.List ioModulesLoadAllInDirectory(@NotNull java.lang.String dirname) {
        java.util.Objects.requireNonNull(dirname, "Parameter 'dirname' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_io_modules_load_all_in_directory.invokeExact(
                    Interop.allocateNativeString(dirname));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.List(RESULT, Ownership.FULL);
    }
    
    /**
     * Loads all the modules in the specified directory.
     * <p>
     * If don't require all modules to be initialized (and thus registering
     * all gtypes) then you can use g_io_modules_scan_all_in_directory()
     * which allows delayed/lazy loading of modules.
     * @param dirname pathname for a directory containing modules
     *     to load.
     * @param scope a scope to use when scanning the modules.
     * @return a list of {@code GIOModules} loaded
     *      from the directory,
     *      All the modules are loaded into memory, if you want to
     *      unload them (enabling on-demand loading) you must call
     *      g_type_module_unuse() on all the modules. Free the list
     *      with g_list_free().
     */
    public static @NotNull org.gtk.glib.List ioModulesLoadAllInDirectoryWithScope(@NotNull java.lang.String dirname, @NotNull org.gtk.gio.IOModuleScope scope) {
        java.util.Objects.requireNonNull(dirname, "Parameter 'dirname' must not be null");
        java.util.Objects.requireNonNull(scope, "Parameter 'scope' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_io_modules_load_all_in_directory_with_scope.invokeExact(
                    Interop.allocateNativeString(dirname),
                    scope.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.List(RESULT, Ownership.FULL);
    }
    
    /**
     * Scans all the modules in the specified directory, ensuring that
     * any extension point implemented by a module is registered.
     * <p>
     * This may not actually load and initialize all the types in each
     * module, some modules may be lazily loaded and initialized when
     * an extension point it implements is used with e.g.
     * g_io_extension_point_get_extensions() or
     * g_io_extension_point_get_extension_by_name().
     * <p>
     * If you need to guarantee that all types are loaded in all the modules,
     * use g_io_modules_load_all_in_directory().
     * @param dirname pathname for a directory containing modules
     *     to scan.
     */
    public static void ioModulesScanAllInDirectory(@NotNull java.lang.String dirname) {
        java.util.Objects.requireNonNull(dirname, "Parameter 'dirname' must not be null");
        try {
            DowncallHandles.g_io_modules_scan_all_in_directory.invokeExact(
                    Interop.allocateNativeString(dirname));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Scans all the modules in the specified directory, ensuring that
     * any extension point implemented by a module is registered.
     * <p>
     * This may not actually load and initialize all the types in each
     * module, some modules may be lazily loaded and initialized when
     * an extension point it implements is used with e.g.
     * g_io_extension_point_get_extensions() or
     * g_io_extension_point_get_extension_by_name().
     * <p>
     * If you need to guarantee that all types are loaded in all the modules,
     * use g_io_modules_load_all_in_directory().
     * @param dirname pathname for a directory containing modules
     *     to scan.
     * @param scope a scope to use when scanning the modules
     */
    public static void ioModulesScanAllInDirectoryWithScope(@NotNull java.lang.String dirname, @NotNull org.gtk.gio.IOModuleScope scope) {
        java.util.Objects.requireNonNull(dirname, "Parameter 'dirname' must not be null");
        java.util.Objects.requireNonNull(scope, "Parameter 'scope' must not be null");
        try {
            DowncallHandles.g_io_modules_scan_all_in_directory_with_scope.invokeExact(
                    Interop.allocateNativeString(dirname),
                    scope.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Cancels all cancellable I/O jobs.
     * <p>
     * A job is cancellable if a {@link Cancellable} was passed into
     * g_io_scheduler_push_job().
     * @deprecated You should never call this function, since you don't
     * know how other libraries in your program might be making use of
     * gioscheduler.
     */
    @Deprecated
    public static void ioSchedulerCancelAllJobs() {
        try {
            DowncallHandles.g_io_scheduler_cancel_all_jobs.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Schedules the I/O job to run in another thread.
     * <p>
     * {@code notify} will be called on {@code user_data} after {@code job_func} has returned,
     * regardless whether the job was cancelled or has run to completion.
     * <p>
     * If {@code cancellable} is not {@code null}, it can be used to cancel the I/O job
     * by calling g_cancellable_cancel() or by calling
     * g_io_scheduler_cancel_all_jobs().
     * @param jobFunc a {@link IOSchedulerJobFunc}.
     * @param ioPriority the [I/O priority][io-priority]
     * of the request.
     * @param cancellable optional {@link Cancellable} object, {@code null} to ignore.
     * @deprecated use {@link org.gtk.glib.ThreadPool} or g_task_run_in_thread()
     */
    @Deprecated
    public static void ioSchedulerPushJob(@NotNull org.gtk.gio.IOSchedulerJobFunc jobFunc, int ioPriority, @Nullable org.gtk.gio.Cancellable cancellable) {
        java.util.Objects.requireNonNull(jobFunc, "Parameter 'jobFunc' must not be null");
        try {
            DowncallHandles.g_io_scheduler_push_job.invokeExact(
                    (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbIOSchedulerJobFunc",
                            MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope()),
                    (Addressable) (Interop.registerCallback(jobFunc)),
                    Interop.cbDestroyNotifySymbol(),
                    ioPriority,
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Creates a keyfile-backed {@link SettingsBackend}.
     * <p>
     * The filename of the keyfile to use is given by {@code filename}.
     * <p>
     * All settings read to or written from the backend must fall under the
     * path given in {@code root_path} (which must start and end with a slash and
     * not contain two consecutive slashes).  {@code root_path} may be "/".
     * <p>
     * If {@code root_group} is non-{@code null} then it specifies the name of the keyfile
     * group used for keys that are written directly below {@code root_path}.  For
     * example, if {@code root_path} is "/apps/example/" and {@code root_group} is
     * "toplevel", then settings the key "/apps/example/enabled" to a value
     * of {@code true} will cause the following to appear in the keyfile:
     * <pre>{@code 
     *   [toplevel]
     *   enabled=true
     * }</pre>
     * <p>
     * If {@code root_group} is {@code null} then it is not permitted to store keys
     * directly below the {@code root_path}.
     * <p>
     * For keys not stored directly below {@code root_path} (ie: in a sub-path),
     * the name of the subpath (with the final slash stripped) is used as
     * the name of the keyfile group.  To continue the example, if
     * "/apps/example/profiles/default/font-size" were set to
     * 12 then the following would appear in the keyfile:
     * <pre>{@code 
     *   [profiles/default]
     *   font-size=12
     * }</pre>
     * <p>
     * The backend will refuse writes (and return writability as being
     * {@code false}) for keys outside of {@code root_path} and, in the event that
     * {@code root_group} is {@code null}, also for keys directly under {@code root_path}.
     * Writes will also be refused if the backend detects that it has the
     * inability to rewrite the keyfile (ie: the containing directory is not
     * writable).
     * <p>
     * There is no checking done for your key namespace clashing with the
     * syntax of the key file format.  For example, if you have '[' or ']'
     * characters in your path names or '=' in your key names you may be in
     * trouble.
     * <p>
     * The backend reads default values from a keyfile called {@code defaults} in
     * the directory specified by the {@code GKeyfileSettingsBackend}:defaults-dir property,
     * and a list of locked keys from a text file with the name {@code locks} in
     * the same location.
     * @param filename the filename of the keyfile
     * @param rootPath the path under which all settings keys appear
     * @param rootGroup the group name corresponding to
     *              {@code root_path}, or {@code null}
     * @return a keyfile-backed {@link SettingsBackend}
     */
    public static @NotNull org.gtk.gio.SettingsBackend keyfileSettingsBackendNew(@NotNull java.lang.String filename, @NotNull java.lang.String rootPath, @Nullable java.lang.String rootGroup) {
        java.util.Objects.requireNonNull(filename, "Parameter 'filename' must not be null");
        java.util.Objects.requireNonNull(rootPath, "Parameter 'rootPath' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_keyfile_settings_backend_new.invokeExact(
                    Interop.allocateNativeString(filename),
                    Interop.allocateNativeString(rootPath),
                    (Addressable) (rootGroup == null ? MemoryAddress.NULL : Interop.allocateNativeString(rootGroup)));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.SettingsBackend(RESULT, Ownership.FULL);
    }
    
    /**
     * Gets a reference to the default {@link MemoryMonitor} for the system.
     * @return a new reference to the default {@link MemoryMonitor}
     */
    public static @NotNull org.gtk.gio.MemoryMonitor memoryMonitorDupDefault() {
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_memory_monitor_dup_default.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.MemoryMonitor.MemoryMonitorImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Creates a memory-backed {@link SettingsBackend}.
     * <p>
     * This backend allows changes to settings, but does not write them
     * to any backing storage, so the next time you run your application,
     * the memory backend will start out with the default values again.
     * @return a newly created {@link SettingsBackend}
     */
    public static @NotNull org.gtk.gio.SettingsBackend memorySettingsBackendNew() {
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_memory_settings_backend_new.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.SettingsBackend(RESULT, Ownership.FULL);
    }
    
    /**
     * Gets the default {@link NetworkMonitor} for the system.
     * @return a {@link NetworkMonitor}, which will be
     *     a dummy object if no network monitor is available
     */
    public static @NotNull org.gtk.gio.NetworkMonitor networkMonitorGetDefault() {
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_network_monitor_get_default.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.NetworkMonitor.NetworkMonitorImpl(RESULT, Ownership.NONE);
    }
    
    /**
     * Initializes the platform networking libraries (eg, on Windows, this
     * calls WSAStartup()). GLib will call this itself if it is needed, so
     * you only need to call it if you directly call system networking
     * functions (without calling any GLib networking functions first).
     */
    public static void networkingInit() {
        try {
            DowncallHandles.g_networking_init.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Creates a readonly {@link SettingsBackend}.
     * <p>
     * This backend does not allow changes to settings, so all settings
     * will always have their default values.
     * @return a newly created {@link SettingsBackend}
     */
    public static @NotNull org.gtk.gio.SettingsBackend nullSettingsBackendNew() {
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_null_settings_backend_new.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.SettingsBackend(RESULT, Ownership.FULL);
    }
    
    /**
     * Utility method for {@link PollableInputStream} and {@link PollableOutputStream}
     * implementations. Creates a new {@link org.gtk.glib.Source} that expects a callback of
     * type {@link PollableSourceFunc}. The new source does not actually do
     * anything on its own; use g_source_add_child_source() to add other
     * sources to it to cause it to trigger.
     * @param pollableStream the stream associated with the new source
     * @return the new {@link org.gtk.glib.Source}.
     */
    public static @NotNull org.gtk.glib.Source pollableSourceNew(@NotNull org.gtk.gobject.Object pollableStream) {
        java.util.Objects.requireNonNull(pollableStream, "Parameter 'pollableStream' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_pollable_source_new.invokeExact(
                    pollableStream.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.Source(RESULT, Ownership.FULL);
    }
    
    /**
     * Utility method for {@link PollableInputStream} and {@link PollableOutputStream}
     * implementations. Creates a new {@link org.gtk.glib.Source}, as with
     * g_pollable_source_new(), but also attaching {@code child_source} (with a
     * dummy callback), and {@code cancellable}, if they are non-{@code null}.
     * @param pollableStream the stream associated with the
     *   new source
     * @param childSource optional child source to attach
     * @param cancellable optional {@link Cancellable} to attach
     * @return the new {@link org.gtk.glib.Source}.
     */
    public static @NotNull org.gtk.glib.Source pollableSourceNewFull(@NotNull org.gtk.gobject.Object pollableStream, @Nullable org.gtk.glib.Source childSource, @Nullable org.gtk.gio.Cancellable cancellable) {
        java.util.Objects.requireNonNull(pollableStream, "Parameter 'pollableStream' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_pollable_source_new_full.invokeExact(
                    pollableStream.handle(),
                    (Addressable) (childSource == null ? MemoryAddress.NULL : childSource.handle()),
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.Source(RESULT, Ownership.FULL);
    }
    
    /**
     * Tries to read from {@code stream}, as with g_input_stream_read() (if
     * {@code blocking} is {@code true}) or g_pollable_input_stream_read_nonblocking()
     * (if {@code blocking} is {@code false}). This can be used to more easily share
     * code between blocking and non-blocking implementations of a method.
     * <p>
     * If {@code blocking} is {@code false}, then {@code stream} must be a
     * {@link PollableInputStream} for which g_pollable_input_stream_can_poll()
     * returns {@code true}, or else the behavior is undefined. If {@code blocking} is
     * {@code true}, then {@code stream} does not need to be a {@link PollableInputStream}.
     * @param stream a {@link InputStream}
     * @param buffer a buffer to
     *   read data into
     * @param count the number of bytes to read
     * @param blocking whether to do blocking I/O
     * @param cancellable optional {@link Cancellable} object, {@code null} to ignore.
     * @return the number of bytes read, or -1 on error.
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static long pollableStreamRead(@NotNull org.gtk.gio.InputStream stream, @NotNull byte[] buffer, long count, boolean blocking, @Nullable org.gtk.gio.Cancellable cancellable) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(stream, "Parameter 'stream' must not be null");
        java.util.Objects.requireNonNull(buffer, "Parameter 'buffer' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        long RESULT;
        try {
            RESULT = (long) DowncallHandles.g_pollable_stream_read.invokeExact(
                    stream.handle(),
                    Interop.allocateNativeArray(buffer, false),
                    count,
                    blocking ? 1 : 0,
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return RESULT;
    }
    
    /**
     * Tries to write to {@code stream}, as with g_output_stream_write() (if
     * {@code blocking} is {@code true}) or g_pollable_output_stream_write_nonblocking()
     * (if {@code blocking} is {@code false}). This can be used to more easily share
     * code between blocking and non-blocking implementations of a method.
     * <p>
     * If {@code blocking} is {@code false}, then {@code stream} must be a
     * {@link PollableOutputStream} for which
     * g_pollable_output_stream_can_poll() returns {@code true} or else the
     * behavior is undefined. If {@code blocking} is {@code true}, then {@code stream} does not
     * need to be a {@link PollableOutputStream}.
     * @param stream a {@link OutputStream}.
     * @param buffer the buffer
     *   containing the data to write.
     * @param count the number of bytes to write
     * @param blocking whether to do blocking I/O
     * @param cancellable optional {@link Cancellable} object, {@code null} to ignore.
     * @return the number of bytes written, or -1 on error.
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static long pollableStreamWrite(@NotNull org.gtk.gio.OutputStream stream, @NotNull byte[] buffer, long count, boolean blocking, @Nullable org.gtk.gio.Cancellable cancellable) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(stream, "Parameter 'stream' must not be null");
        java.util.Objects.requireNonNull(buffer, "Parameter 'buffer' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        long RESULT;
        try {
            RESULT = (long) DowncallHandles.g_pollable_stream_write.invokeExact(
                    stream.handle(),
                    Interop.allocateNativeArray(buffer, false),
                    count,
                    blocking ? 1 : 0,
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return RESULT;
    }
    
    /**
     * Tries to write {@code count} bytes to {@code stream}, as with
     * g_output_stream_write_all(), but using g_pollable_stream_write()
     * rather than g_output_stream_write().
     * <p>
     * On a successful write of {@code count} bytes, {@code true} is returned, and
     * {@code bytes_written} is set to {@code count}.
     * <p>
     * If there is an error during the operation (including
     * {@link IOErrorEnum#WOULD_BLOCK} in the non-blocking case), {@code false} is
     * returned and {@code error} is set to indicate the error status,
     * {@code bytes_written} is updated to contain the number of bytes written
     * into the stream before the error occurred.
     * <p>
     * As with g_pollable_stream_write(), if {@code blocking} is {@code false}, then
     * {@code stream} must be a {@link PollableOutputStream} for which
     * g_pollable_output_stream_can_poll() returns {@code true} or else the
     * behavior is undefined. If {@code blocking} is {@code true}, then {@code stream} does not
     * need to be a {@link PollableOutputStream}.
     * @param stream a {@link OutputStream}.
     * @param buffer the buffer
     *   containing the data to write.
     * @param count the number of bytes to write
     * @param blocking whether to do blocking I/O
     * @param bytesWritten location to store the number of bytes that was
     *   written to the stream
     * @param cancellable optional {@link Cancellable} object, {@code null} to ignore.
     * @return {@code true} on success, {@code false} if there was an error
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static boolean pollableStreamWriteAll(@NotNull org.gtk.gio.OutputStream stream, @NotNull byte[] buffer, long count, boolean blocking, Out<Long> bytesWritten, @Nullable org.gtk.gio.Cancellable cancellable) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(stream, "Parameter 'stream' must not be null");
        java.util.Objects.requireNonNull(buffer, "Parameter 'buffer' must not be null");
        java.util.Objects.requireNonNull(bytesWritten, "Parameter 'bytesWritten' must not be null");
        MemorySegment bytesWrittenPOINTER = Interop.getAllocator().allocate(Interop.valueLayout.C_LONG);
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_pollable_stream_write_all.invokeExact(
                    stream.handle(),
                    Interop.allocateNativeArray(buffer, false),
                    count,
                    blocking ? 1 : 0,
                    (Addressable) bytesWrittenPOINTER.address(),
                    (Addressable) (cancellable == null ? MemoryAddress.NULL : cancellable.handle()),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        bytesWritten.set(bytesWrittenPOINTER.get(Interop.valueLayout.C_LONG, 0));
        return RESULT != 0;
    }
    
    /**
     * Gets a reference to the default {@link PowerProfileMonitor} for the system.
     * @return a new reference to the default {@link PowerProfileMonitor}
     */
    public static @NotNull org.gtk.gio.PowerProfileMonitor powerProfileMonitorDupDefault() {
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_power_profile_monitor_dup_default.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.PowerProfileMonitor.PowerProfileMonitorImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Find the {@code gio-proxy} extension point for a proxy implementation that supports
     * the specified protocol.
     * @param protocol the proxy protocol name (e.g. http, socks, etc)
     * @return return a {@link Proxy} or NULL if protocol
     *               is not supported.
     */
    public static @Nullable org.gtk.gio.Proxy proxyGetDefaultForProtocol(@NotNull java.lang.String protocol) {
        java.util.Objects.requireNonNull(protocol, "Parameter 'protocol' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_proxy_get_default_for_protocol.invokeExact(
                    Interop.allocateNativeString(protocol));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.Proxy.ProxyImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Gets the default {@link ProxyResolver} for the system.
     * @return the default {@link ProxyResolver}, which
     *     will be a dummy object if no proxy resolver is available
     */
    public static @NotNull org.gtk.gio.ProxyResolver proxyResolverGetDefault() {
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_proxy_resolver_get_default.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.ProxyResolver.ProxyResolverImpl(RESULT, Ownership.NONE);
    }
    
    /**
     * Gets the {@link Resolver} Error Quark.
     * @return a {@link org.gtk.glib.Quark}.
     */
    public static @NotNull org.gtk.glib.Quark resolverErrorQuark() {
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_resolver_error_quark.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.Quark(RESULT);
    }
    
    /**
     * Gets the {@link Resource} Error Quark.
     * @return a {@link org.gtk.glib.Quark}
     */
    public static @NotNull org.gtk.glib.Quark resourceErrorQuark() {
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_resource_error_quark.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.Quark(RESULT);
    }
    
    /**
     * Loads a binary resource bundle and creates a {@link Resource} representation of it, allowing
     * you to query it for data.
     * <p>
     * If you want to use this resource in the global resource namespace you need
     * to register it with g_resources_register().
     * <p>
     * If {@code filename} is empty or the data in it is corrupt,
     * {@link ResourceError#INTERNAL} will be returned. If {@code filename} doesnt exist, or
     * there is an error in reading it, an error from g_mapped_file_new() will be
     * returned.
     * @param filename the path of a filename to load, in the GLib filename encoding
     * @return a new {@link Resource}, or {@code null} on error
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.Resource resourceLoad(@NotNull java.lang.String filename) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(filename, "Parameter 'filename' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_resource_load.invokeExact(
                    Interop.allocateNativeString(filename),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.Resource(RESULT, Ownership.FULL);
    }
    
    /**
     * Returns all the names of children at the specified {@code path} in the set of
     * globally registered resources.
     * The return result is a {@code null} terminated list of strings which should
     * be released with g_strfreev().
     * <p>
     * {@code lookup_flags} controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookupFlags A {@link ResourceLookupFlags}
     * @return an array of constant strings
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull PointerString resourcesEnumerateChildren(@NotNull java.lang.String path, @NotNull org.gtk.gio.ResourceLookupFlags lookupFlags) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(path, "Parameter 'path' must not be null");
        java.util.Objects.requireNonNull(lookupFlags, "Parameter 'lookupFlags' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_resources_enumerate_children.invokeExact(
                    Interop.allocateNativeString(path),
                    lookupFlags.getValue(),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new PointerString(RESULT);
    }
    
    /**
     * Looks for a file at the specified {@code path} in the set of
     * globally registered resources and if found returns information about it.
     * <p>
     * {@code lookup_flags} controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookupFlags A {@link ResourceLookupFlags}
     * @param size a location to place the length of the contents of the file,
     *    or {@code null} if the length is not needed
     * @param flags a location to place the {@link ResourceFlags} about the file,
     *    or {@code null} if the flags are not needed
     * @return {@code true} if the file was found. {@code false} if there were errors
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static boolean resourcesGetInfo(@NotNull java.lang.String path, @NotNull org.gtk.gio.ResourceLookupFlags lookupFlags, Out<Long> size, Out<Integer> flags) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(path, "Parameter 'path' must not be null");
        java.util.Objects.requireNonNull(lookupFlags, "Parameter 'lookupFlags' must not be null");
        java.util.Objects.requireNonNull(size, "Parameter 'size' must not be null");
        MemorySegment sizePOINTER = Interop.getAllocator().allocate(Interop.valueLayout.C_LONG);
        java.util.Objects.requireNonNull(flags, "Parameter 'flags' must not be null");
        MemorySegment flagsPOINTER = Interop.getAllocator().allocate(Interop.valueLayout.C_INT);
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_resources_get_info.invokeExact(
                    Interop.allocateNativeString(path),
                    lookupFlags.getValue(),
                    (Addressable) sizePOINTER.address(),
                    (Addressable) flagsPOINTER.address(),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        size.set(sizePOINTER.get(Interop.valueLayout.C_LONG, 0));
        flags.set(flagsPOINTER.get(Interop.valueLayout.C_INT, 0));
        return RESULT != 0;
    }
    
    /**
     * Looks for a file at the specified {@code path} in the set of
     * globally registered resources and returns a {@link org.gtk.glib.Bytes} that
     * lets you directly access the data in memory.
     * <p>
     * The data is always followed by a zero byte, so you
     * can safely use the data as a C string. However, that byte
     * is not included in the size of the GBytes.
     * <p>
     * For uncompressed resource files this is a pointer directly into
     * the resource bundle, which is typically in some readonly data section
     * in the program binary. For compressed files we allocate memory on
     * the heap and automatically uncompress the data.
     * <p>
     * {@code lookup_flags} controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookupFlags A {@link ResourceLookupFlags}
     * @return {@link org.gtk.glib.Bytes} or {@code null} on error.
     *     Free the returned object with g_bytes_unref()
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.glib.Bytes resourcesLookupData(@NotNull java.lang.String path, @NotNull org.gtk.gio.ResourceLookupFlags lookupFlags) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(path, "Parameter 'path' must not be null");
        java.util.Objects.requireNonNull(lookupFlags, "Parameter 'lookupFlags' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_resources_lookup_data.invokeExact(
                    Interop.allocateNativeString(path),
                    lookupFlags.getValue(),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.glib.Bytes(RESULT, Ownership.FULL);
    }
    
    /**
     * Looks for a file at the specified {@code path} in the set of
     * globally registered resources and returns a {@link InputStream}
     * that lets you read the data.
     * <p>
     * {@code lookup_flags} controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookupFlags A {@link ResourceLookupFlags}
     * @return {@link InputStream} or {@code null} on error.
     *     Free the returned object with g_object_unref()
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.InputStream resourcesOpenStream(@NotNull java.lang.String path, @NotNull org.gtk.gio.ResourceLookupFlags lookupFlags) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(path, "Parameter 'path' must not be null");
        java.util.Objects.requireNonNull(lookupFlags, "Parameter 'lookupFlags' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_resources_open_stream.invokeExact(
                    Interop.allocateNativeString(path),
                    lookupFlags.getValue(),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.InputStream(RESULT, Ownership.FULL);
    }
    
    /**
     * Registers the resource with the process-global set of resources.
     * Once a resource is registered the files in it can be accessed
     * with the global resource lookup functions like g_resources_lookup_data().
     * @param resource A {@link Resource}
     */
    public static void resourcesRegister(@NotNull org.gtk.gio.Resource resource) {
        java.util.Objects.requireNonNull(resource, "Parameter 'resource' must not be null");
        try {
            DowncallHandles.g_resources_register.invokeExact(
                    resource.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Unregisters the resource from the process-global set of resources.
     * @param resource A {@link Resource}
     */
    public static void resourcesUnregister(@NotNull org.gtk.gio.Resource resource) {
        java.util.Objects.requireNonNull(resource, "Parameter 'resource' must not be null");
        try {
            DowncallHandles.g_resources_unregister.invokeExact(
                    resource.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Gets the default system schema source.
     * <p>
     * This function is not required for normal uses of {@link Settings} but it
     * may be useful to authors of plugin management systems or to those who
     * want to introspect the content of schemas.
     * <p>
     * If no schemas are installed, {@code null} will be returned.
     * <p>
     * The returned source may actually consist of multiple schema sources
     * from different directories, depending on which directories were given
     * in {@code XDG_DATA_DIRS} and {@code GSETTINGS_SCHEMA_DIR}. For this reason, all
     * lookups performed against the default source should probably be done
     * recursively.
     * @return the default schema source
     */
    public static @Nullable org.gtk.gio.SettingsSchemaSource settingsSchemaSourceGetDefault() {
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_settings_schema_source_get_default.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.SettingsSchemaSource(RESULT, Ownership.NONE);
    }
    
    /**
     * Reports an error in an asynchronous function in an idle function by
     * directly setting the contents of the {@link AsyncResult} with the given error
     * information.
     * @param object a {@link org.gtk.gobject.Object}, or {@code null}.
     * @param callback a {@link AsyncReadyCallback}.
     * @param domain a {@link org.gtk.glib.Quark} containing the error domain (usually {@code G_IO_ERROR}).
     * @param code a specific error code.
     * @param format a formatted error reporting string.
     * @param varargs a list of variables to fill in {@code format}.
     * @deprecated Use g_task_report_error().
     */
    @Deprecated
    public static void simpleAsyncReportErrorInIdle(@Nullable org.gtk.gobject.Object object, @Nullable org.gtk.gio.AsyncReadyCallback callback, @NotNull org.gtk.glib.Quark domain, int code, @NotNull java.lang.String format, java.lang.Object... varargs) {
        java.util.Objects.requireNonNull(domain, "Parameter 'domain' must not be null");
        java.util.Objects.requireNonNull(format, "Parameter 'format' must not be null");
        try {
            DowncallHandles.g_simple_async_report_error_in_idle.invokeExact(
                    (Addressable) (object == null ? MemoryAddress.NULL : object.handle()),
                    (Addressable) (callback == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbAsyncReadyCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (callback == null ? MemoryAddress.NULL : Interop.registerCallback(callback)),
                    domain.getValue().intValue(),
                    code,
                    Interop.allocateNativeString(format),
                    varargs);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Reports an error in an idle function. Similar to
     * g_simple_async_report_error_in_idle(), but takes a {@link org.gtk.glib.Error} rather
     * than building a new one.
     * @param object a {@link org.gtk.gobject.Object}, or {@code null}
     * @param callback a {@link AsyncReadyCallback}.
     * @param error the {@link org.gtk.glib.Error} to report
     * @deprecated Use g_task_report_error().
     */
    @Deprecated
    public static void simpleAsyncReportGerrorInIdle(@Nullable org.gtk.gobject.Object object, @Nullable org.gtk.gio.AsyncReadyCallback callback, @NotNull org.gtk.glib.Error error) {
        java.util.Objects.requireNonNull(error, "Parameter 'error' must not be null");
        try {
            DowncallHandles.g_simple_async_report_gerror_in_idle.invokeExact(
                    (Addressable) (object == null ? MemoryAddress.NULL : object.handle()),
                    (Addressable) (callback == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbAsyncReadyCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (callback == null ? MemoryAddress.NULL : Interop.registerCallback(callback)),
                    error.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Reports an error in an idle function. Similar to
     * g_simple_async_report_gerror_in_idle(), but takes over the caller's
     * ownership of {@code error}, so the caller does not have to free it any more.
     * @param object a {@link org.gtk.gobject.Object}, or {@code null}
     * @param callback a {@link AsyncReadyCallback}.
     * @param error the {@link org.gtk.glib.Error} to report
     * @deprecated Use g_task_report_error().
     */
    @Deprecated
    public static void simpleAsyncReportTakeGerrorInIdle(@Nullable org.gtk.gobject.Object object, @Nullable org.gtk.gio.AsyncReadyCallback callback, @NotNull org.gtk.glib.Error error) {
        java.util.Objects.requireNonNull(error, "Parameter 'error' must not be null");
        try {
            DowncallHandles.g_simple_async_report_take_gerror_in_idle.invokeExact(
                    (Addressable) (object == null ? MemoryAddress.NULL : object.handle()),
                    (Addressable) (callback == null ? MemoryAddress.NULL : (Addressable) Linker.nativeLinker().upcallStub(
                        MethodHandles.lookup().findStatic(Gio.Callbacks.class, "cbAsyncReadyCallback",
                            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class)),
                        FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
                        Interop.getScope())),
                    (Addressable) (callback == null ? MemoryAddress.NULL : Interop.registerCallback(callback)),
                    error.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Sorts {@code targets} in place according to the algorithm in RFC 2782.
     * @param targets a {@link org.gtk.glib.List} of {@link SrvTarget}
     * @return the head of the sorted list.
     */
    public static @NotNull org.gtk.glib.List srvTargetListSort(@NotNull org.gtk.glib.List targets) {
        java.util.Objects.requireNonNull(targets, "Parameter 'targets' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_srv_target_list_sort.invokeExact(
                    targets.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.List(RESULT, Ownership.FULL);
    }
    
    /**
     * Gets the default {@link TlsBackend} for the system.
     * @return a {@link TlsBackend}, which will be a
     *     dummy object if no TLS backend is available
     */
    public static @NotNull org.gtk.gio.TlsBackend tlsBackendGetDefault() {
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_tls_backend_get_default.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.TlsBackend.TlsBackendImpl(RESULT, Ownership.NONE);
    }
    
    /**
     * Gets the TLS channel binding error quark.
     * @return a {@link org.gtk.glib.Quark}.
     */
    public static @NotNull org.gtk.glib.Quark tlsChannelBindingErrorQuark() {
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_tls_channel_binding_error_quark.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.Quark(RESULT);
    }
    
    /**
     * Creates a new {@link TlsClientConnection} wrapping {@code base_io_stream} (which
     * must have pollable input and output streams) which is assumed to
     * communicate with the server identified by {@code server_identity}.
     * <p>
     * See the documentation for {@link TlsConnection}:base-io-stream for restrictions
     * on when application code can run operations on the {@code base_io_stream} after
     * this function has returned.
     * @param baseIoStream the {@link IOStream} to wrap
     * @param serverIdentity the expected identity of the server
     * @return the new
     * {@link TlsClientConnection}, or {@code null} on error
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.TlsClientConnection tlsClientConnectionNew(@NotNull org.gtk.gio.IOStream baseIoStream, @Nullable org.gtk.gio.SocketConnectable serverIdentity) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(baseIoStream, "Parameter 'baseIoStream' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_tls_client_connection_new.invokeExact(
                    baseIoStream.handle(),
                    (Addressable) (serverIdentity == null ? MemoryAddress.NULL : serverIdentity.handle()),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.TlsClientConnection.TlsClientConnectionImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Gets the TLS error quark.
     * @return a {@link org.gtk.glib.Quark}.
     */
    public static @NotNull org.gtk.glib.Quark tlsErrorQuark() {
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_tls_error_quark.invokeExact();
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.glib.Quark(RESULT);
    }
    
    /**
     * Creates a new {@link TlsFileDatabase} which uses anchor certificate authorities
     * in {@code anchors} to verify certificate chains.
     * <p>
     * The certificates in {@code anchors} must be PEM encoded.
     * @param anchors filename of anchor certificate authorities.
     * @return the new
     * {@link TlsFileDatabase}, or {@code null} on error
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.TlsFileDatabase tlsFileDatabaseNew(@NotNull java.lang.String anchors) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(anchors, "Parameter 'anchors' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_tls_file_database_new.invokeExact(
                    Interop.allocateNativeString(anchors),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.TlsFileDatabase.TlsFileDatabaseImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Creates a new {@link TlsServerConnection} wrapping {@code base_io_stream} (which
     * must have pollable input and output streams).
     * <p>
     * See the documentation for {@link TlsConnection}:base-io-stream for restrictions
     * on when application code can run operations on the {@code base_io_stream} after
     * this function has returned.
     * @param baseIoStream the {@link IOStream} to wrap
     * @param certificate the default server certificate, or {@code null}
     * @return the new
     * {@link TlsServerConnection}, or {@code null} on error
     * @throws GErrorException See {@link org.gtk.glib.Error}
     */
    public static @NotNull org.gtk.gio.TlsServerConnection tlsServerConnectionNew(@NotNull org.gtk.gio.IOStream baseIoStream, @Nullable org.gtk.gio.TlsCertificate certificate) throws io.github.jwharm.javagi.GErrorException {
        java.util.Objects.requireNonNull(baseIoStream, "Parameter 'baseIoStream' must not be null");
        MemorySegment GERROR = Interop.getAllocator().allocate(Interop.valueLayout.ADDRESS);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_tls_server_connection_new.invokeExact(
                    baseIoStream.handle(),
                    (Addressable) (certificate == null ? MemoryAddress.NULL : certificate.handle()),
                    (Addressable) GERROR);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        if (GErrorException.isErrorSet(GERROR)) {
            throw new GErrorException(GERROR);
        }
        return new org.gtk.gio.TlsServerConnection.TlsServerConnectionImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Determines if {@code mount_path} is considered an implementation of the
     * OS. This is primarily used for hiding mountable and mounted volumes
     * that only are used in the OS and has little to no relevance to the
     * casual user.
     * @param mountPath a mount path, e.g. {@code /media/disk} or {@code /usr}
     * @return {@code true} if {@code mount_path} is considered an implementation detail
     *     of the OS.
     */
    public static boolean unixIsMountPathSystemInternal(@NotNull java.lang.String mountPath) {
        java.util.Objects.requireNonNull(mountPath, "Parameter 'mountPath' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_unix_is_mount_path_system_internal.invokeExact(
                    Interop.allocateNativeString(mountPath));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Determines if {@code device_path} is considered a block device path which is only
     * used in implementation of the OS. This is primarily used for hiding
     * mounted volumes that are intended as APIs for programs to read, and system
     * administrators at a shell; rather than something that should, for example,
     * appear in a GUI. For example, the Linux {@code /proc} filesystem.
     * <p>
     * The list of device paths considered system ones may change over time.
     * @param devicePath a device path, e.g. {@code /dev/loop0} or {@code nfsd}
     * @return {@code true} if {@code device_path} is considered an implementation detail of
     *    the OS.
     */
    public static boolean unixIsSystemDevicePath(@NotNull java.lang.String devicePath) {
        java.util.Objects.requireNonNull(devicePath, "Parameter 'devicePath' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_unix_is_system_device_path.invokeExact(
                    Interop.allocateNativeString(devicePath));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Determines if {@code fs_type} is considered a type of file system which is only
     * used in implementation of the OS. This is primarily used for hiding
     * mounted volumes that are intended as APIs for programs to read, and system
     * administrators at a shell; rather than something that should, for example,
     * appear in a GUI. For example, the Linux {@code /proc} filesystem.
     * <p>
     * The list of file system types considered system ones may change over time.
     * @param fsType a file system type, e.g. {@code procfs} or {@code tmpfs}
     * @return {@code true} if {@code fs_type} is considered an implementation detail of the OS.
     */
    public static boolean unixIsSystemFsType(@NotNull java.lang.String fsType) {
        java.util.Objects.requireNonNull(fsType, "Parameter 'fsType' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_unix_is_system_fs_type.invokeExact(
                    Interop.allocateNativeString(fsType));
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Gets a {@link UnixMountEntry} for a given mount path. If {@code time_read}
     * is set, it will be filled with a unix timestamp for checking
     * if the mounts have changed since with g_unix_mounts_changed_since().
     * <p>
     * If more mounts have the same mount path, the last matching mount
     * is returned.
     * <p>
     * This will return {@code null} if there is no mount point at {@code mount_path}.
     * @param mountPath path for a possible unix mount.
     * @param timeRead guint64 to contain a timestamp.
     * @return a {@link UnixMountEntry}.
     */
    public static @Nullable org.gtk.gio.UnixMountEntry unixMountAt(@NotNull java.lang.String mountPath, Out<Long> timeRead) {
        java.util.Objects.requireNonNull(mountPath, "Parameter 'mountPath' must not be null");
        java.util.Objects.requireNonNull(timeRead, "Parameter 'timeRead' must not be null");
        MemorySegment timeReadPOINTER = Interop.getAllocator().allocate(Interop.valueLayout.C_LONG);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_unix_mount_at.invokeExact(
                    Interop.allocateNativeString(mountPath),
                    (Addressable) timeReadPOINTER.address());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        timeRead.set(timeReadPOINTER.get(Interop.valueLayout.C_LONG, 0));
        return new org.gtk.gio.UnixMountEntry(RESULT, Ownership.FULL);
    }
    
    /**
     * Compares two unix mounts.
     * @param mount1 first {@link UnixMountEntry} to compare.
     * @param mount2 second {@link UnixMountEntry} to compare.
     * @return 1, 0 or -1 if {@code mount1} is greater than, equal to,
     * or less than {@code mount2}, respectively.
     */
    public static int unixMountCompare(@NotNull org.gtk.gio.UnixMountEntry mount1, @NotNull org.gtk.gio.UnixMountEntry mount2) {
        java.util.Objects.requireNonNull(mount1, "Parameter 'mount1' must not be null");
        java.util.Objects.requireNonNull(mount2, "Parameter 'mount2' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_unix_mount_compare.invokeExact(
                    mount1.handle(),
                    mount2.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT;
    }
    
    /**
     * Makes a copy of {@code mount_entry}.
     * @param mountEntry a {@link UnixMountEntry}.
     * @return a new {@link UnixMountEntry}
     */
    public static @NotNull org.gtk.gio.UnixMountEntry unixMountCopy(@NotNull org.gtk.gio.UnixMountEntry mountEntry) {
        java.util.Objects.requireNonNull(mountEntry, "Parameter 'mountEntry' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_unix_mount_copy.invokeExact(
                    mountEntry.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.UnixMountEntry(RESULT, Ownership.FULL);
    }
    
    /**
     * Gets a {@link UnixMountEntry} for a given file path. If {@code time_read}
     * is set, it will be filled with a unix timestamp for checking
     * if the mounts have changed since with g_unix_mounts_changed_since().
     * <p>
     * If more mounts have the same mount path, the last matching mount
     * is returned.
     * <p>
     * This will return {@code null} if looking up the mount entry fails, if
     * {@code file_path} doesnt exist or there is an I/O error.
     * @param filePath file path on some unix mount.
     * @param timeRead guint64 to contain a timestamp.
     * @return a {@link UnixMountEntry}.
     */
    public static @Nullable org.gtk.gio.UnixMountEntry unixMountFor(@NotNull java.lang.String filePath, Out<Long> timeRead) {
        java.util.Objects.requireNonNull(filePath, "Parameter 'filePath' must not be null");
        java.util.Objects.requireNonNull(timeRead, "Parameter 'timeRead' must not be null");
        MemorySegment timeReadPOINTER = Interop.getAllocator().allocate(Interop.valueLayout.C_LONG);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_unix_mount_for.invokeExact(
                    Interop.allocateNativeString(filePath),
                    (Addressable) timeReadPOINTER.address());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        timeRead.set(timeReadPOINTER.get(Interop.valueLayout.C_LONG, 0));
        return new org.gtk.gio.UnixMountEntry(RESULT, Ownership.FULL);
    }
    
    /**
     * Frees a unix mount.
     * @param mountEntry a {@link UnixMountEntry}.
     */
    public static void unixMountFree(@NotNull org.gtk.gio.UnixMountEntry mountEntry) {
        java.util.Objects.requireNonNull(mountEntry, "Parameter 'mountEntry' must not be null");
        try {
            DowncallHandles.g_unix_mount_free.invokeExact(
                    mountEntry.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
    }
    
    /**
     * Gets the device path for a unix mount.
     * @param mountEntry a {@code GUnixMount}.
     * @return a string containing the device path.
     */
    public static @NotNull java.lang.String unixMountGetDevicePath(@NotNull org.gtk.gio.UnixMountEntry mountEntry) {
        java.util.Objects.requireNonNull(mountEntry, "Parameter 'mountEntry' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_unix_mount_get_device_path.invokeExact(
                    mountEntry.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Gets the filesystem type for the unix mount.
     * @param mountEntry a {@code GUnixMount}.
     * @return a string containing the file system type.
     */
    public static @NotNull java.lang.String unixMountGetFsType(@NotNull org.gtk.gio.UnixMountEntry mountEntry) {
        java.util.Objects.requireNonNull(mountEntry, "Parameter 'mountEntry' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_unix_mount_get_fs_type.invokeExact(
                    mountEntry.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Gets the mount path for a unix mount.
     * @param mountEntry input {@link UnixMountEntry} to get the mount path for.
     * @return the mount path for {@code mount_entry}.
     */
    public static @NotNull java.lang.String unixMountGetMountPath(@NotNull org.gtk.gio.UnixMountEntry mountEntry) {
        java.util.Objects.requireNonNull(mountEntry, "Parameter 'mountEntry' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_unix_mount_get_mount_path.invokeExact(
                    mountEntry.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Gets a comma-separated list of mount options for the unix mount. For example,
     * {@code rw,relatime,seclabel,data=ordered}.
     * <p>
     * This is similar to g_unix_mount_point_get_options(), but it takes
     * a {@link UnixMountEntry} as an argument.
     * @param mountEntry a {@link UnixMountEntry}.
     * @return a string containing the options, or {@code null} if not
     * available.
     */
    public static @Nullable java.lang.String unixMountGetOptions(@NotNull org.gtk.gio.UnixMountEntry mountEntry) {
        java.util.Objects.requireNonNull(mountEntry, "Parameter 'mountEntry' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_unix_mount_get_options.invokeExact(
                    mountEntry.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Gets the root of the mount within the filesystem. This is useful e.g. for
     * mounts created by bind operation, or btrfs subvolumes.
     * <p>
     * For example, the root path is equal to "/" for mount created by
     * "mount /dev/sda1 /mnt/foo" and "/bar" for
     * "mount --bind /mnt/foo/bar /mnt/bar".
     * @param mountEntry a {@link UnixMountEntry}.
     * @return a string containing the root, or {@code null} if not supported.
     */
    public static @Nullable java.lang.String unixMountGetRootPath(@NotNull org.gtk.gio.UnixMountEntry mountEntry) {
        java.util.Objects.requireNonNull(mountEntry, "Parameter 'mountEntry' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_unix_mount_get_root_path.invokeExact(
                    mountEntry.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Guesses whether a Unix mount can be ejected.
     * @param mountEntry a {@link UnixMountEntry}
     * @return {@code true} if {@code mount_entry} is deemed to be ejectable.
     */
    public static boolean unixMountGuessCanEject(@NotNull org.gtk.gio.UnixMountEntry mountEntry) {
        java.util.Objects.requireNonNull(mountEntry, "Parameter 'mountEntry' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_unix_mount_guess_can_eject.invokeExact(
                    mountEntry.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Guesses the icon of a Unix mount.
     * @param mountEntry a {@link UnixMountEntry}
     * @return a {@link Icon}
     */
    public static @NotNull org.gtk.gio.Icon unixMountGuessIcon(@NotNull org.gtk.gio.UnixMountEntry mountEntry) {
        java.util.Objects.requireNonNull(mountEntry, "Parameter 'mountEntry' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_unix_mount_guess_icon.invokeExact(
                    mountEntry.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.Icon.IconImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Guesses the name of a Unix mount.
     * The result is a translated string.
     * @param mountEntry a {@link UnixMountEntry}
     * @return A newly allocated string that must
     *     be freed with g_free()
     */
    public static @NotNull java.lang.String unixMountGuessName(@NotNull org.gtk.gio.UnixMountEntry mountEntry) {
        java.util.Objects.requireNonNull(mountEntry, "Parameter 'mountEntry' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_unix_mount_guess_name.invokeExact(
                    mountEntry.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return Interop.getStringFrom(RESULT);
    }
    
    /**
     * Guesses whether a Unix mount should be displayed in the UI.
     * @param mountEntry a {@link UnixMountEntry}
     * @return {@code true} if {@code mount_entry} is deemed to be displayable.
     */
    public static boolean unixMountGuessShouldDisplay(@NotNull org.gtk.gio.UnixMountEntry mountEntry) {
        java.util.Objects.requireNonNull(mountEntry, "Parameter 'mountEntry' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_unix_mount_guess_should_display.invokeExact(
                    mountEntry.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Guesses the symbolic icon of a Unix mount.
     * @param mountEntry a {@link UnixMountEntry}
     * @return a {@link Icon}
     */
    public static @NotNull org.gtk.gio.Icon unixMountGuessSymbolicIcon(@NotNull org.gtk.gio.UnixMountEntry mountEntry) {
        java.util.Objects.requireNonNull(mountEntry, "Parameter 'mountEntry' must not be null");
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_unix_mount_guess_symbolic_icon.invokeExact(
                    mountEntry.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return new org.gtk.gio.Icon.IconImpl(RESULT, Ownership.FULL);
    }
    
    /**
     * Checks if a unix mount is mounted read only.
     * @param mountEntry a {@code GUnixMount}.
     * @return {@code true} if {@code mount_entry} is read only.
     */
    public static boolean unixMountIsReadonly(@NotNull org.gtk.gio.UnixMountEntry mountEntry) {
        java.util.Objects.requireNonNull(mountEntry, "Parameter 'mountEntry' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_unix_mount_is_readonly.invokeExact(
                    mountEntry.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Checks if a Unix mount is a system mount. This is the Boolean OR of
     * g_unix_is_system_fs_type(), g_unix_is_system_device_path() and
     * g_unix_is_mount_path_system_internal() on {@code mount_entry}s properties.
     * <p>
     * The definition of what a system mount entry is may change over time as new
     * file system types and device paths are ignored.
     * @param mountEntry a {@code GUnixMount}.
     * @return {@code true} if the unix mount is for a system path.
     */
    public static boolean unixMountIsSystemInternal(@NotNull org.gtk.gio.UnixMountEntry mountEntry) {
        java.util.Objects.requireNonNull(mountEntry, "Parameter 'mountEntry' must not be null");
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_unix_mount_is_system_internal.invokeExact(
                    mountEntry.handle());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Gets a {@link UnixMountPoint} for a given mount path. If {@code time_read} is set, it
     * will be filled with a unix timestamp for checking if the mount points have
     * changed since with g_unix_mount_points_changed_since().
     * <p>
     * If more mount points have the same mount path, the last matching mount point
     * is returned.
     * @param mountPath path for a possible unix mount point.
     * @param timeRead guint64 to contain a timestamp.
     * @return a {@link UnixMountPoint}, or {@code null} if no match
     * is found.
     */
    public static @Nullable org.gtk.gio.UnixMountPoint unixMountPointAt(@NotNull java.lang.String mountPath, Out<Long> timeRead) {
        java.util.Objects.requireNonNull(mountPath, "Parameter 'mountPath' must not be null");
        java.util.Objects.requireNonNull(timeRead, "Parameter 'timeRead' must not be null");
        MemorySegment timeReadPOINTER = Interop.getAllocator().allocate(Interop.valueLayout.C_LONG);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_unix_mount_point_at.invokeExact(
                    Interop.allocateNativeString(mountPath),
                    (Addressable) timeReadPOINTER.address());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        timeRead.set(timeReadPOINTER.get(Interop.valueLayout.C_LONG, 0));
        return new org.gtk.gio.UnixMountPoint(RESULT, Ownership.FULL);
    }
    
    /**
     * Checks if the unix mount points have changed since a given unix time.
     * @param time guint64 to contain a timestamp.
     * @return {@code true} if the mount points have changed since {@code time}.
     */
    public static boolean unixMountPointsChangedSince(long time) {
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_unix_mount_points_changed_since.invokeExact(
                    time);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Gets a {@link org.gtk.glib.List} of {@link UnixMountPoint} containing the unix mount points.
     * If {@code time_read} is set, it will be filled with the mount timestamp,
     * allowing for checking if the mounts have changed with
     * g_unix_mount_points_changed_since().
     * @param timeRead guint64 to contain a timestamp.
     * @return a {@link org.gtk.glib.List} of the UNIX mountpoints.
     */
    public static @NotNull org.gtk.glib.List unixMountPointsGet(Out<Long> timeRead) {
        java.util.Objects.requireNonNull(timeRead, "Parameter 'timeRead' must not be null");
        MemorySegment timeReadPOINTER = Interop.getAllocator().allocate(Interop.valueLayout.C_LONG);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_unix_mount_points_get.invokeExact(
                    (Addressable) timeReadPOINTER.address());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        timeRead.set(timeReadPOINTER.get(Interop.valueLayout.C_LONG, 0));
        return new org.gtk.glib.List(RESULT, Ownership.FULL);
    }
    
    /**
     * Checks if the unix mounts have changed since a given unix time.
     * @param time guint64 to contain a timestamp.
     * @return {@code true} if the mounts have changed since {@code time}.
     */
    public static boolean unixMountsChangedSince(long time) {
        int RESULT;
        try {
            RESULT = (int) DowncallHandles.g_unix_mounts_changed_since.invokeExact(
                    time);
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        return RESULT != 0;
    }
    
    /**
     * Gets a {@link org.gtk.glib.List} of {@link UnixMountEntry} containing the unix mounts.
     * If {@code time_read} is set, it will be filled with the mount
     * timestamp, allowing for checking if the mounts have changed
     * with g_unix_mounts_changed_since().
     * @param timeRead guint64 to contain a timestamp, or {@code null}
     * @return a {@link org.gtk.glib.List} of the UNIX mounts.
     */
    public static @NotNull org.gtk.glib.List unixMountsGet(Out<Long> timeRead) {
        java.util.Objects.requireNonNull(timeRead, "Parameter 'timeRead' must not be null");
        MemorySegment timeReadPOINTER = Interop.getAllocator().allocate(Interop.valueLayout.C_LONG);
        MemoryAddress RESULT;
        try {
            RESULT = (MemoryAddress) DowncallHandles.g_unix_mounts_get.invokeExact(
                    (Addressable) timeReadPOINTER.address());
        } catch (Throwable ERR) {
            throw new AssertionError("Unexpected exception occured: ", ERR);
        }
        timeRead.set(timeReadPOINTER.get(Interop.valueLayout.C_LONG, 0));
        return new org.gtk.glib.List(RESULT, Ownership.FULL);
    }
    
    private static class DowncallHandles {
        
        private static final MethodHandle g_action_name_is_valid = Interop.downcallHandle(
            "g_action_name_is_valid",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_action_parse_detailed_name = Interop.downcallHandle(
            "g_action_parse_detailed_name",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_action_print_detailed_name = Interop.downcallHandle(
            "g_action_print_detailed_name",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_app_info_create_from_commandline = Interop.downcallHandle(
            "g_app_info_create_from_commandline",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_app_info_get_all = Interop.downcallHandle(
            "g_app_info_get_all",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_app_info_get_all_for_type = Interop.downcallHandle(
            "g_app_info_get_all_for_type",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_app_info_get_default_for_type = Interop.downcallHandle(
            "g_app_info_get_default_for_type",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT),
            false
        );
        
        private static final MethodHandle g_app_info_get_default_for_type_async = Interop.downcallHandle(
            "g_app_info_get_default_for_type_async",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_app_info_get_default_for_type_finish = Interop.downcallHandle(
            "g_app_info_get_default_for_type_finish",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_app_info_get_default_for_uri_scheme = Interop.downcallHandle(
            "g_app_info_get_default_for_uri_scheme",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_app_info_get_default_for_uri_scheme_async = Interop.downcallHandle(
            "g_app_info_get_default_for_uri_scheme_async",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_app_info_get_default_for_uri_scheme_finish = Interop.downcallHandle(
            "g_app_info_get_default_for_uri_scheme_finish",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_app_info_get_fallback_for_type = Interop.downcallHandle(
            "g_app_info_get_fallback_for_type",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_app_info_get_recommended_for_type = Interop.downcallHandle(
            "g_app_info_get_recommended_for_type",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_app_info_launch_default_for_uri = Interop.downcallHandle(
            "g_app_info_launch_default_for_uri",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_app_info_launch_default_for_uri_async = Interop.downcallHandle(
            "g_app_info_launch_default_for_uri_async",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_app_info_launch_default_for_uri_finish = Interop.downcallHandle(
            "g_app_info_launch_default_for_uri_finish",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_app_info_reset_type_associations = Interop.downcallHandle(
            "g_app_info_reset_type_associations",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_async_initable_newv_async = Interop.downcallHandle(
            "g_async_initable_newv_async",
            FunctionDescriptor.ofVoid(Interop.valueLayout.C_LONG, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_bus_get = Interop.downcallHandle(
            "g_bus_get",
            FunctionDescriptor.ofVoid(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_bus_get_finish = Interop.downcallHandle(
            "g_bus_get_finish",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_bus_get_sync = Interop.downcallHandle(
            "g_bus_get_sync",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_bus_own_name = Interop.downcallHandle(
            "g_bus_own_name",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_bus_own_name_on_connection = Interop.downcallHandle(
            "g_bus_own_name_on_connection",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_bus_own_name_on_connection_with_closures = Interop.downcallHandle(
            "g_bus_own_name_on_connection_with_closures",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_bus_own_name_with_closures = Interop.downcallHandle(
            "g_bus_own_name_with_closures",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_bus_unown_name = Interop.downcallHandle(
            "g_bus_unown_name",
            FunctionDescriptor.ofVoid(Interop.valueLayout.C_INT),
            false
        );
        
        private static final MethodHandle g_bus_unwatch_name = Interop.downcallHandle(
            "g_bus_unwatch_name",
            FunctionDescriptor.ofVoid(Interop.valueLayout.C_INT),
            false
        );
        
        private static final MethodHandle g_bus_watch_name = Interop.downcallHandle(
            "g_bus_watch_name",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_bus_watch_name_on_connection = Interop.downcallHandle(
            "g_bus_watch_name_on_connection",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_bus_watch_name_on_connection_with_closures = Interop.downcallHandle(
            "g_bus_watch_name_on_connection_with_closures",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_bus_watch_name_with_closures = Interop.downcallHandle(
            "g_bus_watch_name_with_closures",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_content_type_can_be_executable = Interop.downcallHandle(
            "g_content_type_can_be_executable",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_content_type_equals = Interop.downcallHandle(
            "g_content_type_equals",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_content_type_from_mime_type = Interop.downcallHandle(
            "g_content_type_from_mime_type",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_content_type_get_description = Interop.downcallHandle(
            "g_content_type_get_description",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_content_type_get_generic_icon_name = Interop.downcallHandle(
            "g_content_type_get_generic_icon_name",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_content_type_get_icon = Interop.downcallHandle(
            "g_content_type_get_icon",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_content_type_get_mime_dirs = Interop.downcallHandle(
            "g_content_type_get_mime_dirs",
            FunctionDescriptor.ofVoid(),
            false
        );
        
        private static final MethodHandle g_content_type_get_mime_type = Interop.downcallHandle(
            "g_content_type_get_mime_type",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_content_type_get_symbolic_icon = Interop.downcallHandle(
            "g_content_type_get_symbolic_icon",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_content_type_guess = Interop.downcallHandle(
            "g_content_type_guess",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_LONG, Interop.valueLayout.C_INT),
            false
        );
        
        private static final MethodHandle g_content_type_guess_for_tree = Interop.downcallHandle(
            "g_content_type_guess_for_tree",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_content_type_is_a = Interop.downcallHandle(
            "g_content_type_is_a",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_content_type_is_mime_type = Interop.downcallHandle(
            "g_content_type_is_mime_type",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_content_type_is_unknown = Interop.downcallHandle(
            "g_content_type_is_unknown",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_content_type_set_mime_dirs = Interop.downcallHandle(
            "g_content_type_set_mime_dirs",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_content_types_get_registered = Interop.downcallHandle(
            "g_content_types_get_registered",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_address_escape_value = Interop.downcallHandle(
            "g_dbus_address_escape_value",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_address_get_for_bus_sync = Interop.downcallHandle(
            "g_dbus_address_get_for_bus_sync",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_address_get_stream = Interop.downcallHandle(
            "g_dbus_address_get_stream",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_address_get_stream_finish = Interop.downcallHandle(
            "g_dbus_address_get_stream_finish",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_address_get_stream_sync = Interop.downcallHandle(
            "g_dbus_address_get_stream_sync",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_annotation_info_lookup = Interop.downcallHandle(
            "g_dbus_annotation_info_lookup",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_error_encode_gerror = Interop.downcallHandle(
            "g_dbus_error_encode_gerror",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_error_get_remote_error = Interop.downcallHandle(
            "g_dbus_error_get_remote_error",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_error_is_remote_error = Interop.downcallHandle(
            "g_dbus_error_is_remote_error",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_error_new_for_dbus_error = Interop.downcallHandle(
            "g_dbus_error_new_for_dbus_error",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_error_quark = Interop.downcallHandle(
            "g_dbus_error_quark",
            FunctionDescriptor.of(Interop.valueLayout.C_INT),
            false
        );
        
        private static final MethodHandle g_dbus_error_register_error = Interop.downcallHandle(
            "g_dbus_error_register_error",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.C_INT, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_error_register_error_domain = Interop.downcallHandle(
            "g_dbus_error_register_error_domain",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT),
            false
        );
        
        private static final MethodHandle g_dbus_error_strip_remote_error = Interop.downcallHandle(
            "g_dbus_error_strip_remote_error",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_error_unregister_error = Interop.downcallHandle(
            "g_dbus_error_unregister_error",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.C_INT, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_escape_object_path = Interop.downcallHandle(
            "g_dbus_escape_object_path",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_escape_object_path_bytestring = Interop.downcallHandle(
            "g_dbus_escape_object_path_bytestring",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_generate_guid = Interop.downcallHandle(
            "g_dbus_generate_guid",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_gvalue_to_gvariant = Interop.downcallHandle(
            "g_dbus_gvalue_to_gvariant",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_gvariant_to_gvalue = Interop.downcallHandle(
            "g_dbus_gvariant_to_gvalue",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_is_address = Interop.downcallHandle(
            "g_dbus_is_address",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_is_error_name = Interop.downcallHandle(
            "g_dbus_is_error_name",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_is_guid = Interop.downcallHandle(
            "g_dbus_is_guid",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_is_interface_name = Interop.downcallHandle(
            "g_dbus_is_interface_name",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_is_member_name = Interop.downcallHandle(
            "g_dbus_is_member_name",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_is_name = Interop.downcallHandle(
            "g_dbus_is_name",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_is_supported_address = Interop.downcallHandle(
            "g_dbus_is_supported_address",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_is_unique_name = Interop.downcallHandle(
            "g_dbus_is_unique_name",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dbus_unescape_object_path = Interop.downcallHandle(
            "g_dbus_unescape_object_path",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dtls_client_connection_new = Interop.downcallHandle(
            "g_dtls_client_connection_new",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_dtls_server_connection_new = Interop.downcallHandle(
            "g_dtls_server_connection_new",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_file_new_for_commandline_arg = Interop.downcallHandle(
            "g_file_new_for_commandline_arg",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_file_new_for_commandline_arg_and_cwd = Interop.downcallHandle(
            "g_file_new_for_commandline_arg_and_cwd",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_file_new_for_path = Interop.downcallHandle(
            "g_file_new_for_path",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_file_new_for_uri = Interop.downcallHandle(
            "g_file_new_for_uri",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_file_new_tmp = Interop.downcallHandle(
            "g_file_new_tmp",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_file_new_tmp_async = Interop.downcallHandle(
            "g_file_new_tmp_async",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_file_new_tmp_dir_async = Interop.downcallHandle(
            "g_file_new_tmp_dir_async",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_file_new_tmp_dir_finish = Interop.downcallHandle(
            "g_file_new_tmp_dir_finish",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_file_new_tmp_finish = Interop.downcallHandle(
            "g_file_new_tmp_finish",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_file_parse_name = Interop.downcallHandle(
            "g_file_parse_name",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_icon_deserialize = Interop.downcallHandle(
            "g_icon_deserialize",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_icon_hash = Interop.downcallHandle(
            "g_icon_hash",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_icon_new_for_string = Interop.downcallHandle(
            "g_icon_new_for_string",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_initable_newv = Interop.downcallHandle(
            "g_initable_newv",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.C_LONG, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_io_error_from_errno = Interop.downcallHandle(
            "g_io_error_from_errno",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.C_INT),
            false
        );
        
        private static final MethodHandle g_io_error_from_file_error = Interop.downcallHandle(
            "g_io_error_from_file_error",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.C_INT),
            false
        );
        
        private static final MethodHandle g_io_error_quark = Interop.downcallHandle(
            "g_io_error_quark",
            FunctionDescriptor.of(Interop.valueLayout.C_INT),
            false
        );
        
        private static final MethodHandle g_io_extension_point_implement = Interop.downcallHandle(
            "g_io_extension_point_implement",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_LONG, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT),
            false
        );
        
        private static final MethodHandle g_io_extension_point_lookup = Interop.downcallHandle(
            "g_io_extension_point_lookup",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_io_extension_point_register = Interop.downcallHandle(
            "g_io_extension_point_register",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_io_modules_load_all_in_directory = Interop.downcallHandle(
            "g_io_modules_load_all_in_directory",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_io_modules_load_all_in_directory_with_scope = Interop.downcallHandle(
            "g_io_modules_load_all_in_directory_with_scope",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_io_modules_scan_all_in_directory = Interop.downcallHandle(
            "g_io_modules_scan_all_in_directory",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_io_modules_scan_all_in_directory_with_scope = Interop.downcallHandle(
            "g_io_modules_scan_all_in_directory_with_scope",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_io_scheduler_cancel_all_jobs = Interop.downcallHandle(
            "g_io_scheduler_cancel_all_jobs",
            FunctionDescriptor.ofVoid(),
            false
        );
        
        private static final MethodHandle g_io_scheduler_push_job = Interop.downcallHandle(
            "g_io_scheduler_push_job",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_keyfile_settings_backend_new = Interop.downcallHandle(
            "g_keyfile_settings_backend_new",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_memory_monitor_dup_default = Interop.downcallHandle(
            "g_memory_monitor_dup_default",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_memory_settings_backend_new = Interop.downcallHandle(
            "g_memory_settings_backend_new",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_network_monitor_get_default = Interop.downcallHandle(
            "g_network_monitor_get_default",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_networking_init = Interop.downcallHandle(
            "g_networking_init",
            FunctionDescriptor.ofVoid(),
            false
        );
        
        private static final MethodHandle g_null_settings_backend_new = Interop.downcallHandle(
            "g_null_settings_backend_new",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_pollable_source_new = Interop.downcallHandle(
            "g_pollable_source_new",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_pollable_source_new_full = Interop.downcallHandle(
            "g_pollable_source_new_full",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_pollable_stream_read = Interop.downcallHandle(
            "g_pollable_stream_read",
            FunctionDescriptor.of(Interop.valueLayout.C_LONG, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_LONG, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_pollable_stream_write = Interop.downcallHandle(
            "g_pollable_stream_write",
            FunctionDescriptor.of(Interop.valueLayout.C_LONG, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_LONG, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_pollable_stream_write_all = Interop.downcallHandle(
            "g_pollable_stream_write_all",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_LONG, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_power_profile_monitor_dup_default = Interop.downcallHandle(
            "g_power_profile_monitor_dup_default",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_proxy_get_default_for_protocol = Interop.downcallHandle(
            "g_proxy_get_default_for_protocol",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_proxy_resolver_get_default = Interop.downcallHandle(
            "g_proxy_resolver_get_default",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_resolver_error_quark = Interop.downcallHandle(
            "g_resolver_error_quark",
            FunctionDescriptor.of(Interop.valueLayout.C_INT),
            false
        );
        
        private static final MethodHandle g_resource_error_quark = Interop.downcallHandle(
            "g_resource_error_quark",
            FunctionDescriptor.of(Interop.valueLayout.C_INT),
            false
        );
        
        private static final MethodHandle g_resource_load = Interop.downcallHandle(
            "g_resource_load",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_resources_enumerate_children = Interop.downcallHandle(
            "g_resources_enumerate_children",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_resources_get_info = Interop.downcallHandle(
            "g_resources_get_info",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_resources_lookup_data = Interop.downcallHandle(
            "g_resources_lookup_data",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_resources_open_stream = Interop.downcallHandle(
            "g_resources_open_stream",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_resources_register = Interop.downcallHandle(
            "g_resources_register",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_resources_unregister = Interop.downcallHandle(
            "g_resources_unregister",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_settings_schema_source_get_default = Interop.downcallHandle(
            "g_settings_schema_source_get_default",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_simple_async_report_error_in_idle = Interop.downcallHandle(
            "g_simple_async_report_error_in_idle",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.C_INT, Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            true
        );
        
        private static final MethodHandle g_simple_async_report_gerror_in_idle = Interop.downcallHandle(
            "g_simple_async_report_gerror_in_idle",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_simple_async_report_take_gerror_in_idle = Interop.downcallHandle(
            "g_simple_async_report_take_gerror_in_idle",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_srv_target_list_sort = Interop.downcallHandle(
            "g_srv_target_list_sort",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_tls_backend_get_default = Interop.downcallHandle(
            "g_tls_backend_get_default",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_tls_channel_binding_error_quark = Interop.downcallHandle(
            "g_tls_channel_binding_error_quark",
            FunctionDescriptor.of(Interop.valueLayout.C_INT),
            false
        );
        
        private static final MethodHandle g_tls_client_connection_new = Interop.downcallHandle(
            "g_tls_client_connection_new",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_tls_error_quark = Interop.downcallHandle(
            "g_tls_error_quark",
            FunctionDescriptor.of(Interop.valueLayout.C_INT),
            false
        );
        
        private static final MethodHandle g_tls_file_database_new = Interop.downcallHandle(
            "g_tls_file_database_new",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_tls_server_connection_new = Interop.downcallHandle(
            "g_tls_server_connection_new",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_is_mount_path_system_internal = Interop.downcallHandle(
            "g_unix_is_mount_path_system_internal",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_is_system_device_path = Interop.downcallHandle(
            "g_unix_is_system_device_path",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_is_system_fs_type = Interop.downcallHandle(
            "g_unix_is_system_fs_type",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_at = Interop.downcallHandle(
            "g_unix_mount_at",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_compare = Interop.downcallHandle(
            "g_unix_mount_compare",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_copy = Interop.downcallHandle(
            "g_unix_mount_copy",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_for = Interop.downcallHandle(
            "g_unix_mount_for",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_free = Interop.downcallHandle(
            "g_unix_mount_free",
            FunctionDescriptor.ofVoid(Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_get_device_path = Interop.downcallHandle(
            "g_unix_mount_get_device_path",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_get_fs_type = Interop.downcallHandle(
            "g_unix_mount_get_fs_type",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_get_mount_path = Interop.downcallHandle(
            "g_unix_mount_get_mount_path",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_get_options = Interop.downcallHandle(
            "g_unix_mount_get_options",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_get_root_path = Interop.downcallHandle(
            "g_unix_mount_get_root_path",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_guess_can_eject = Interop.downcallHandle(
            "g_unix_mount_guess_can_eject",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_guess_icon = Interop.downcallHandle(
            "g_unix_mount_guess_icon",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_guess_name = Interop.downcallHandle(
            "g_unix_mount_guess_name",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_guess_should_display = Interop.downcallHandle(
            "g_unix_mount_guess_should_display",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_guess_symbolic_icon = Interop.downcallHandle(
            "g_unix_mount_guess_symbolic_icon",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_is_readonly = Interop.downcallHandle(
            "g_unix_mount_is_readonly",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_is_system_internal = Interop.downcallHandle(
            "g_unix_mount_is_system_internal",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_point_at = Interop.downcallHandle(
            "g_unix_mount_point_at",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mount_points_changed_since = Interop.downcallHandle(
            "g_unix_mount_points_changed_since",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.C_LONG),
            false
        );
        
        private static final MethodHandle g_unix_mount_points_get = Interop.downcallHandle(
            "g_unix_mount_points_get",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
        
        private static final MethodHandle g_unix_mounts_changed_since = Interop.downcallHandle(
            "g_unix_mounts_changed_since",
            FunctionDescriptor.of(Interop.valueLayout.C_INT, Interop.valueLayout.C_LONG),
            false
        );
        
        private static final MethodHandle g_unix_mounts_get = Interop.downcallHandle(
            "g_unix_mounts_get",
            FunctionDescriptor.of(Interop.valueLayout.ADDRESS, Interop.valueLayout.ADDRESS),
            false
        );
    }
    
    @ApiStatus.Internal
    public static class Callbacks {
        
        public static void cbBusNameVanishedCallback(MemoryAddress connection, MemoryAddress name, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (BusNameVanishedCallback) Interop.signalRegistry.get(HASH);
            HANDLER.onBusNameVanishedCallback(new org.gtk.gio.DBusConnection(connection, Ownership.NONE), Interop.getStringFrom(name));
        }
        
        public static void cbBusNameAppearedCallback(MemoryAddress connection, MemoryAddress name, MemoryAddress nameOwner, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (BusNameAppearedCallback) Interop.signalRegistry.get(HASH);
            HANDLER.onBusNameAppearedCallback(new org.gtk.gio.DBusConnection(connection, Ownership.NONE), Interop.getStringFrom(name), Interop.getStringFrom(nameOwner));
        }
        
        public static void cbFileMeasureProgressCallback(int reporting, long currentSize, long numDirs, long numFiles, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (FileMeasureProgressCallback) Interop.signalRegistry.get(HASH);
            HANDLER.onFileMeasureProgressCallback(reporting != 0, currentSize, numDirs, numFiles);
        }
        
        public static boolean cbDatagramBasedSourceFunc(MemoryAddress datagramBased, int condition, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (DatagramBasedSourceFunc) Interop.signalRegistry.get(HASH);
            var RESULT = HANDLER.onDatagramBasedSourceFunc(new org.gtk.gio.DatagramBased.DatagramBasedImpl(datagramBased, Ownership.NONE), new org.gtk.glib.IOCondition(condition));
            return RESULT;
        }
        
        public static boolean cbSettingsGetMapping(MemoryAddress value, MemoryAddress result, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (SettingsGetMapping) Interop.signalRegistry.get(HASH);
        var resultOUT = new Out<java.lang.foreign.MemoryAddress>(result);
            var RESULT = HANDLER.onSettingsGetMapping(new org.gtk.glib.Variant(value, Ownership.NONE), resultOUT);
            result.set(Interop.valueLayout.ADDRESS, 0, (Addressable) resultOUT.get());
            return RESULT;
        }
        
        public static org.gtk.glib.Variant cbDBusInterfaceGetPropertyFunc(MemoryAddress connection, MemoryAddress sender, MemoryAddress objectPath, MemoryAddress interfaceName, MemoryAddress propertyName, MemoryAddress error, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (DBusInterfaceGetPropertyFunc) Interop.signalRegistry.get(HASH);
            var RESULT = HANDLER.onDBusInterfaceGetPropertyFunc(new org.gtk.gio.DBusConnection(connection, Ownership.NONE), Interop.getStringFrom(sender), Interop.getStringFrom(objectPath), Interop.getStringFrom(interfaceName), Interop.getStringFrom(propertyName), new PointerProxy<org.gtk.glib.Error>(error, org.gtk.glib.Error.class));
            return RESULT;
        }
        
        public static void cbBusAcquiredCallback(MemoryAddress connection, MemoryAddress name, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (BusAcquiredCallback) Interop.signalRegistry.get(HASH);
            HANDLER.onBusAcquiredCallback(new org.gtk.gio.DBusConnection(connection, Ownership.NONE), Interop.getStringFrom(name));
        }
        
        public static org.gtk.glib.Variant cbSettingsBindSetMapping(MemoryAddress value, MemoryAddress expectedType, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (SettingsBindSetMapping) Interop.signalRegistry.get(HASH);
            var RESULT = HANDLER.onSettingsBindSetMapping(new org.gtk.gobject.Value(value, Ownership.NONE), new org.gtk.glib.VariantType(expectedType, Ownership.NONE));
            return RESULT;
        }
        
        public static java.lang.foreign.MemoryAddress cbReallocFunc(MemoryAddress data, long size) {
            int HASH = data.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (ReallocFunc) Interop.signalRegistry.get(HASH);
            var RESULT = HANDLER.onReallocFunc(size);
            return RESULT;
        }
        
        public static boolean cbCancellableSourceFunc(MemoryAddress cancellable, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (CancellableSourceFunc) Interop.signalRegistry.get(HASH);
            var RESULT = HANDLER.onCancellableSourceFunc(new org.gtk.gio.Cancellable(cancellable, Ownership.NONE));
            return RESULT;
        }
        
        public static boolean cbDBusInterfaceSetPropertyFunc(MemoryAddress connection, MemoryAddress sender, MemoryAddress objectPath, MemoryAddress interfaceName, MemoryAddress propertyName, MemoryAddress value, MemoryAddress error, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (DBusInterfaceSetPropertyFunc) Interop.signalRegistry.get(HASH);
            var RESULT = HANDLER.onDBusInterfaceSetPropertyFunc(new org.gtk.gio.DBusConnection(connection, Ownership.NONE), Interop.getStringFrom(sender), Interop.getStringFrom(objectPath), Interop.getStringFrom(interfaceName), Interop.getStringFrom(propertyName), new org.gtk.glib.Variant(value, Ownership.NONE), new PointerProxy<org.gtk.glib.Error>(error, org.gtk.glib.Error.class));
            return RESULT;
        }
        
        public static void cbBusNameLostCallback(MemoryAddress connection, MemoryAddress name, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (BusNameLostCallback) Interop.signalRegistry.get(HASH);
            HANDLER.onBusNameLostCallback(new org.gtk.gio.DBusConnection(connection, Ownership.NONE), Interop.getStringFrom(name));
        }
        
        public static boolean cbFileReadMoreCallback(MemoryAddress fileContents, long fileSize, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (FileReadMoreCallback) Interop.signalRegistry.get(HASH);
            var RESULT = HANDLER.onFileReadMoreCallback(Interop.getStringFrom(fileContents), fileSize);
            return RESULT;
        }
        
        public static boolean cbSocketSourceFunc(MemoryAddress socket, int condition, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (SocketSourceFunc) Interop.signalRegistry.get(HASH);
            var RESULT = HANDLER.onSocketSourceFunc(new org.gtk.gio.Socket(socket, Ownership.NONE), new org.gtk.glib.IOCondition(condition));
            return RESULT;
        }
        
        public static void cbDesktopAppLaunchCallback(MemoryAddress appinfo, int pid, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (DesktopAppLaunchCallback) Interop.signalRegistry.get(HASH);
            HANDLER.onDesktopAppLaunchCallback(new org.gtk.gio.DesktopAppInfo(appinfo, Ownership.NONE), new org.gtk.glib.Pid(pid));
        }
        
        public static boolean cbPollableSourceFunc(MemoryAddress pollableStream, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (PollableSourceFunc) Interop.signalRegistry.get(HASH);
            var RESULT = HANDLER.onPollableSourceFunc(new org.gtk.gobject.Object(pollableStream, Ownership.NONE));
            return RESULT;
        }
        
        public static void cbAsyncReadyCallback(MemoryAddress sourceObject, MemoryAddress res, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (AsyncReadyCallback) Interop.signalRegistry.get(HASH);
            HANDLER.onAsyncReadyCallback(new org.gtk.gobject.Object(sourceObject, Ownership.NONE), new org.gtk.gio.AsyncResult.AsyncResultImpl(res, Ownership.NONE));
        }
        
        public static boolean cbSettingsBindGetMapping(MemoryAddress value, MemoryAddress variant, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (SettingsBindGetMapping) Interop.signalRegistry.get(HASH);
            var RESULT = HANDLER.onSettingsBindGetMapping(new org.gtk.gobject.Value(value, Ownership.NONE), new org.gtk.glib.Variant(variant, Ownership.NONE));
            return RESULT;
        }
        
        public static org.gtk.gio.DBusInterfaceVTable cbDBusSubtreeDispatchFunc(MemoryAddress connection, MemoryAddress sender, MemoryAddress objectPath, MemoryAddress interfaceName, MemoryAddress node, MemoryAddress outUserData, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (DBusSubtreeDispatchFunc) Interop.signalRegistry.get(HASH);
            var RESULT = HANDLER.onDBusSubtreeDispatchFunc(new org.gtk.gio.DBusConnection(connection, Ownership.NONE), Interop.getStringFrom(sender), Interop.getStringFrom(objectPath), Interop.getStringFrom(interfaceName), Interop.getStringFrom(node), outUserData);
            return RESULT;
        }
        
        public static void cbDBusSignalCallback(MemoryAddress connection, MemoryAddress senderName, MemoryAddress objectPath, MemoryAddress interfaceName, MemoryAddress signalName, MemoryAddress parameters, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (DBusSignalCallback) Interop.signalRegistry.get(HASH);
            HANDLER.onDBusSignalCallback(new org.gtk.gio.DBusConnection(connection, Ownership.NONE), Interop.getStringFrom(senderName), Interop.getStringFrom(objectPath), Interop.getStringFrom(interfaceName), Interop.getStringFrom(signalName), new org.gtk.glib.Variant(parameters, Ownership.NONE));
        }
        
        public static void cbFileProgressCallback(long currentNumBytes, long totalNumBytes, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (FileProgressCallback) Interop.signalRegistry.get(HASH);
            HANDLER.onFileProgressCallback(currentNumBytes, totalNumBytes);
        }
        
        public static org.gtk.gio.File cbVfsFileLookupFunc(MemoryAddress vfs, MemoryAddress identifier, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (VfsFileLookupFunc) Interop.signalRegistry.get(HASH);
            var RESULT = HANDLER.onVfsFileLookupFunc(new org.gtk.gio.Vfs(vfs, Ownership.NONE), Interop.getStringFrom(identifier));
            return RESULT;
        }
        
        public static void cbDBusInterfaceMethodCallFunc(MemoryAddress connection, MemoryAddress sender, MemoryAddress objectPath, MemoryAddress interfaceName, MemoryAddress methodName, MemoryAddress parameters, MemoryAddress invocation, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (DBusInterfaceMethodCallFunc) Interop.signalRegistry.get(HASH);
            HANDLER.onDBusInterfaceMethodCallFunc(new org.gtk.gio.DBusConnection(connection, Ownership.NONE), Interop.getStringFrom(sender), Interop.getStringFrom(objectPath), Interop.getStringFrom(interfaceName), Interop.getStringFrom(methodName), new org.gtk.glib.Variant(parameters, Ownership.NONE), new org.gtk.gio.DBusMethodInvocation(invocation, Ownership.FULL));
        }
        
        public static void cbDBusSubtreeEnumerateFunc(MemoryAddress connection, MemoryAddress sender, MemoryAddress objectPath, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (DBusSubtreeEnumerateFunc) Interop.signalRegistry.get(HASH);
            HANDLER.onDBusSubtreeEnumerateFunc(new org.gtk.gio.DBusConnection(connection, Ownership.NONE), Interop.getStringFrom(sender), Interop.getStringFrom(objectPath));
        }
        
        public static org.gtk.gio.DBusMessage cbDBusMessageFilterFunction(MemoryAddress connection, MemoryAddress message, int incoming, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (DBusMessageFilterFunction) Interop.signalRegistry.get(HASH);
            var RESULT = HANDLER.onDBusMessageFilterFunction(new org.gtk.gio.DBusConnection(connection, Ownership.NONE), new org.gtk.gio.DBusMessage(message, Ownership.FULL), incoming != 0);
            return RESULT;
        }
        
        public static void cbDBusSubtreeIntrospectFunc(MemoryAddress connection, MemoryAddress sender, MemoryAddress objectPath, MemoryAddress node, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (DBusSubtreeIntrospectFunc) Interop.signalRegistry.get(HASH);
            HANDLER.onDBusSubtreeIntrospectFunc(new org.gtk.gio.DBusConnection(connection, Ownership.NONE), Interop.getStringFrom(sender), Interop.getStringFrom(objectPath), Interop.getStringFrom(node));
        }
        
        public static org.gtk.glib.Type cbDBusProxyTypeFunc(MemoryAddress manager, MemoryAddress objectPath, MemoryAddress interfaceName, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (DBusProxyTypeFunc) Interop.signalRegistry.get(HASH);
            var RESULT = HANDLER.onDBusProxyTypeFunc(new org.gtk.gio.DBusObjectManagerClient(manager, Ownership.NONE), Interop.getStringFrom(objectPath), Interop.getStringFrom(interfaceName));
            return RESULT;
        }
        
        public static void cbTaskThreadFunc(MemoryAddress task, MemoryAddress sourceObject, MemoryAddress taskData, MemoryAddress cancellable) {
            int HASH = taskData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (TaskThreadFunc) Interop.signalRegistry.get(HASH);
            HANDLER.onTaskThreadFunc(new org.gtk.gio.Task(task, Ownership.NONE), new org.gtk.gobject.Object(sourceObject, Ownership.NONE), new org.gtk.gio.Cancellable(cancellable, Ownership.NONE));
        }
        
        public static void cbBusNameAcquiredCallback(MemoryAddress connection, MemoryAddress name, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (BusNameAcquiredCallback) Interop.signalRegistry.get(HASH);
            HANDLER.onBusNameAcquiredCallback(new org.gtk.gio.DBusConnection(connection, Ownership.NONE), Interop.getStringFrom(name));
        }
        
        public static boolean cbIOSchedulerJobFunc(MemoryAddress job, MemoryAddress cancellable, MemoryAddress userData) {
            int HASH = userData.get(Interop.valueLayout.C_INT, 0);
            var HANDLER = (IOSchedulerJobFunc) Interop.signalRegistry.get(HASH);
            var RESULT = HANDLER.onIOSchedulerJobFunc(new org.gtk.gio.IOSchedulerJob(job, Ownership.NONE), new org.gtk.gio.Cancellable(cancellable, Ownership.NONE));
            return RESULT;
        }
    }
}
