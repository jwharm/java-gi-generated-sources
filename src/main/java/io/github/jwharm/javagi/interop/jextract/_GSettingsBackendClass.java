// Generated by jextract

package io.github.jwharm.javagi.interop.jextract;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class _GSettingsBackendClass {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        MemoryLayout.structLayout(
            MemoryLayout.structLayout(
                Constants$root.C_LONG_LONG$LAYOUT.withName("g_type")
            ).withName("g_type_class"),
            Constants$root.C_POINTER$LAYOUT.withName("construct_properties"),
            Constants$root.C_POINTER$LAYOUT.withName("constructor"),
            Constants$root.C_POINTER$LAYOUT.withName("set_property"),
            Constants$root.C_POINTER$LAYOUT.withName("get_property"),
            Constants$root.C_POINTER$LAYOUT.withName("dispose"),
            Constants$root.C_POINTER$LAYOUT.withName("finalize"),
            Constants$root.C_POINTER$LAYOUT.withName("dispatch_properties_changed"),
            Constants$root.C_POINTER$LAYOUT.withName("notify"),
            Constants$root.C_POINTER$LAYOUT.withName("constructed"),
            Constants$root.C_LONG_LONG$LAYOUT.withName("flags"),
            MemoryLayout.sequenceLayout(6, Constants$root.C_POINTER$LAYOUT).withName("pdummy")
        ).withName("parent_class"),
        Constants$root.C_POINTER$LAYOUT.withName("read"),
        Constants$root.C_POINTER$LAYOUT.withName("get_writable"),
        Constants$root.C_POINTER$LAYOUT.withName("write"),
        Constants$root.C_POINTER$LAYOUT.withName("write_tree"),
        Constants$root.C_POINTER$LAYOUT.withName("reset"),
        Constants$root.C_POINTER$LAYOUT.withName("subscribe"),
        Constants$root.C_POINTER$LAYOUT.withName("unsubscribe"),
        Constants$root.C_POINTER$LAYOUT.withName("sync"),
        Constants$root.C_POINTER$LAYOUT.withName("get_permission"),
        Constants$root.C_POINTER$LAYOUT.withName("read_user_value"),
        MemoryLayout.sequenceLayout(23, Constants$root.C_POINTER$LAYOUT).withName("padding")
    ).withName("_GSettingsBackendClass");
    public static MemoryLayout $LAYOUT() {
        return _GSettingsBackendClass.$struct$LAYOUT;
    }
    public static MemorySegment parent_class$slice(MemorySegment seg) {
        return seg.asSlice(0, 136);
    }
    static final FunctionDescriptor read$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle read$MH = RuntimeHelper.downcallHandle(
        _GSettingsBackendClass.read$FUNC
    );
    public interface read {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(read fi, MemorySession session) {
            return RuntimeHelper.upcallStub(read.class, fi, _GSettingsBackendClass.read$FUNC, session);
        }
        static read ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GSettingsBackendClass.read$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle read$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("read"));
    public static VarHandle read$VH() {
        return _GSettingsBackendClass.read$VH;
    }
    public static MemoryAddress read$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.read$VH.get(seg);
    }
    public static void read$set( MemorySegment seg, MemoryAddress x) {
        _GSettingsBackendClass.read$VH.set(seg, x);
    }
    public static MemoryAddress read$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.read$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void read$set(MemorySegment seg, long index, MemoryAddress x) {
        _GSettingsBackendClass.read$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static read read (MemorySegment segment, MemorySession session) {
        return read.ofAddress(read$get(segment), session);
    }
    static final FunctionDescriptor get_writable$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_writable$MH = RuntimeHelper.downcallHandle(
        _GSettingsBackendClass.get_writable$FUNC
    );
    public interface get_writable {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(get_writable fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_writable.class, fi, _GSettingsBackendClass.get_writable$FUNC, session);
        }
        static get_writable ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)_GSettingsBackendClass.get_writable$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_writable$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_writable"));
    public static VarHandle get_writable$VH() {
        return _GSettingsBackendClass.get_writable$VH;
    }
    public static MemoryAddress get_writable$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.get_writable$VH.get(seg);
    }
    public static void get_writable$set( MemorySegment seg, MemoryAddress x) {
        _GSettingsBackendClass.get_writable$VH.set(seg, x);
    }
    public static MemoryAddress get_writable$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.get_writable$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_writable$set(MemorySegment seg, long index, MemoryAddress x) {
        _GSettingsBackendClass.get_writable$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_writable get_writable (MemorySegment segment, MemorySession session) {
        return get_writable.ofAddress(get_writable$get(segment), session);
    }
    static final FunctionDescriptor write$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle write$MH = RuntimeHelper.downcallHandle(
        _GSettingsBackendClass.write$FUNC
    );
    public interface write {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(write fi, MemorySession session) {
            return RuntimeHelper.upcallStub(write.class, fi, _GSettingsBackendClass.write$FUNC, session);
        }
        static write ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)_GSettingsBackendClass.write$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle write$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("write"));
    public static VarHandle write$VH() {
        return _GSettingsBackendClass.write$VH;
    }
    public static MemoryAddress write$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.write$VH.get(seg);
    }
    public static void write$set( MemorySegment seg, MemoryAddress x) {
        _GSettingsBackendClass.write$VH.set(seg, x);
    }
    public static MemoryAddress write$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.write$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void write$set(MemorySegment seg, long index, MemoryAddress x) {
        _GSettingsBackendClass.write$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static write write (MemorySegment segment, MemorySession session) {
        return write.ofAddress(write$get(segment), session);
    }
    static final FunctionDescriptor write_tree$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle write_tree$MH = RuntimeHelper.downcallHandle(
        _GSettingsBackendClass.write_tree$FUNC
    );
    public interface write_tree {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(write_tree fi, MemorySession session) {
            return RuntimeHelper.upcallStub(write_tree.class, fi, _GSettingsBackendClass.write_tree$FUNC, session);
        }
        static write_tree ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GSettingsBackendClass.write_tree$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle write_tree$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("write_tree"));
    public static VarHandle write_tree$VH() {
        return _GSettingsBackendClass.write_tree$VH;
    }
    public static MemoryAddress write_tree$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.write_tree$VH.get(seg);
    }
    public static void write_tree$set( MemorySegment seg, MemoryAddress x) {
        _GSettingsBackendClass.write_tree$VH.set(seg, x);
    }
    public static MemoryAddress write_tree$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.write_tree$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void write_tree$set(MemorySegment seg, long index, MemoryAddress x) {
        _GSettingsBackendClass.write_tree$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static write_tree write_tree (MemorySegment segment, MemorySession session) {
        return write_tree.ofAddress(write_tree$get(segment), session);
    }
    static final FunctionDescriptor reset$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle reset$MH = RuntimeHelper.downcallHandle(
        _GSettingsBackendClass.reset$FUNC
    );
    public interface reset {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(reset fi, MemorySession session) {
            return RuntimeHelper.upcallStub(reset.class, fi, _GSettingsBackendClass.reset$FUNC, session);
        }
        static reset ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    _GSettingsBackendClass.reset$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle reset$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("reset"));
    public static VarHandle reset$VH() {
        return _GSettingsBackendClass.reset$VH;
    }
    public static MemoryAddress reset$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.reset$VH.get(seg);
    }
    public static void reset$set( MemorySegment seg, MemoryAddress x) {
        _GSettingsBackendClass.reset$VH.set(seg, x);
    }
    public static MemoryAddress reset$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.reset$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void reset$set(MemorySegment seg, long index, MemoryAddress x) {
        _GSettingsBackendClass.reset$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static reset reset (MemorySegment segment, MemorySession session) {
        return reset.ofAddress(reset$get(segment), session);
    }
    static final FunctionDescriptor subscribe$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle subscribe$MH = RuntimeHelper.downcallHandle(
        _GSettingsBackendClass.subscribe$FUNC
    );
    public interface subscribe {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(subscribe fi, MemorySession session) {
            return RuntimeHelper.upcallStub(subscribe.class, fi, _GSettingsBackendClass.subscribe$FUNC, session);
        }
        static subscribe ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    _GSettingsBackendClass.subscribe$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle subscribe$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("subscribe"));
    public static VarHandle subscribe$VH() {
        return _GSettingsBackendClass.subscribe$VH;
    }
    public static MemoryAddress subscribe$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.subscribe$VH.get(seg);
    }
    public static void subscribe$set( MemorySegment seg, MemoryAddress x) {
        _GSettingsBackendClass.subscribe$VH.set(seg, x);
    }
    public static MemoryAddress subscribe$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.subscribe$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void subscribe$set(MemorySegment seg, long index, MemoryAddress x) {
        _GSettingsBackendClass.subscribe$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static subscribe subscribe (MemorySegment segment, MemorySession session) {
        return subscribe.ofAddress(subscribe$get(segment), session);
    }
    static final FunctionDescriptor unsubscribe$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle unsubscribe$MH = RuntimeHelper.downcallHandle(
        _GSettingsBackendClass.unsubscribe$FUNC
    );
    public interface unsubscribe {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(unsubscribe fi, MemorySession session) {
            return RuntimeHelper.upcallStub(unsubscribe.class, fi, _GSettingsBackendClass.unsubscribe$FUNC, session);
        }
        static unsubscribe ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    _GSettingsBackendClass.unsubscribe$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle unsubscribe$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("unsubscribe"));
    public static VarHandle unsubscribe$VH() {
        return _GSettingsBackendClass.unsubscribe$VH;
    }
    public static MemoryAddress unsubscribe$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.unsubscribe$VH.get(seg);
    }
    public static void unsubscribe$set( MemorySegment seg, MemoryAddress x) {
        _GSettingsBackendClass.unsubscribe$VH.set(seg, x);
    }
    public static MemoryAddress unsubscribe$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.unsubscribe$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void unsubscribe$set(MemorySegment seg, long index, MemoryAddress x) {
        _GSettingsBackendClass.unsubscribe$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static unsubscribe unsubscribe (MemorySegment segment, MemorySession session) {
        return unsubscribe.ofAddress(unsubscribe$get(segment), session);
    }
    static final FunctionDescriptor sync$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle sync$MH = RuntimeHelper.downcallHandle(
        _GSettingsBackendClass.sync$FUNC
    );
    public interface sync {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(sync fi, MemorySession session) {
            return RuntimeHelper.upcallStub(sync.class, fi, _GSettingsBackendClass.sync$FUNC, session);
        }
        static sync ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _GSettingsBackendClass.sync$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle sync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("sync"));
    public static VarHandle sync$VH() {
        return _GSettingsBackendClass.sync$VH;
    }
    public static MemoryAddress sync$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.sync$VH.get(seg);
    }
    public static void sync$set( MemorySegment seg, MemoryAddress x) {
        _GSettingsBackendClass.sync$VH.set(seg, x);
    }
    public static MemoryAddress sync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.sync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void sync$set(MemorySegment seg, long index, MemoryAddress x) {
        _GSettingsBackendClass.sync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static sync sync (MemorySegment segment, MemorySession session) {
        return sync.ofAddress(sync$get(segment), session);
    }
    static final FunctionDescriptor get_permission$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_permission$MH = RuntimeHelper.downcallHandle(
        _GSettingsBackendClass.get_permission$FUNC
    );
    public interface get_permission {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(get_permission fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_permission.class, fi, _GSettingsBackendClass.get_permission$FUNC, session);
        }
        static get_permission ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GSettingsBackendClass.get_permission$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_permission$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_permission"));
    public static VarHandle get_permission$VH() {
        return _GSettingsBackendClass.get_permission$VH;
    }
    public static MemoryAddress get_permission$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.get_permission$VH.get(seg);
    }
    public static void get_permission$set( MemorySegment seg, MemoryAddress x) {
        _GSettingsBackendClass.get_permission$VH.set(seg, x);
    }
    public static MemoryAddress get_permission$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.get_permission$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_permission$set(MemorySegment seg, long index, MemoryAddress x) {
        _GSettingsBackendClass.get_permission$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_permission get_permission (MemorySegment segment, MemorySession session) {
        return get_permission.ofAddress(get_permission$get(segment), session);
    }
    static final FunctionDescriptor read_user_value$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle read_user_value$MH = RuntimeHelper.downcallHandle(
        _GSettingsBackendClass.read_user_value$FUNC
    );
    public interface read_user_value {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(read_user_value fi, MemorySession session) {
            return RuntimeHelper.upcallStub(read_user_value.class, fi, _GSettingsBackendClass.read_user_value$FUNC, session);
        }
        static read_user_value ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GSettingsBackendClass.read_user_value$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle read_user_value$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("read_user_value"));
    public static VarHandle read_user_value$VH() {
        return _GSettingsBackendClass.read_user_value$VH;
    }
    public static MemoryAddress read_user_value$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.read_user_value$VH.get(seg);
    }
    public static void read_user_value$set( MemorySegment seg, MemoryAddress x) {
        _GSettingsBackendClass.read_user_value$VH.set(seg, x);
    }
    public static MemoryAddress read_user_value$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GSettingsBackendClass.read_user_value$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void read_user_value$set(MemorySegment seg, long index, MemoryAddress x) {
        _GSettingsBackendClass.read_user_value$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static read_user_value read_user_value (MemorySegment segment, MemorySession session) {
        return read_user_value.ofAddress(read_user_value$get(segment), session);
    }
    public static MemorySegment padding$slice(MemorySegment seg) {
        return seg.asSlice(216, 184);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


